## Task Analysis
- Main objective: Implement Task 12 by delivering a reliable core persistence service for match sessions (`saveMatchState`, `loadMatchState`, `clearMatchState`) that updates `updatedAt` on save and fails safely (`null`) for missing/corrupt/invalid payloads.
- Identified dependencies: Task 11 outputs are the primary dependency (`utils/match-state-schema.js` for `STORAGE_KEY`, serialization, and `isMatchState` validation; `utils/match-storage.js` adapter structure), plus existing Node test conventions in `tests/match-storage.test.js` and runtime storage behavior patterns from `utils/storage.js`.
- System impact: Medium in persistence utilities and tests (`utils/match-storage.js`, `tests/match-storage.test.js`), low in UI/runtime pages if no integration wiring is changed yet (`page/index.js`, `page/game.js` stay out of scope for this task).

## Chosen Approach
- Proposed solution: Enhance the existing Task 11 persistence module (`utils/match-storage.js`) instead of creating a second service, keeping `ZeppOsStorageAdapter` as the single storage abstraction and implementing Task 12 requirements directly in `saveMatchState`/`loadMatchState`/`clearMatchState` behaviors plus targeted tests.
- Justification for simplicity: Deepthink + brainstorming considered (A) full rewrite/new persistence module, (B) dual-module bridge between legacy `utils/storage.js` and schema service, and (C) focused enhancement of current `match-storage` implementation; (C) is simplest and safest because architecture already exists, minimizes surface area, and directly addresses only missing acceptance points (notably timestamp update coverage and explicit safe-failure validation).
- Components to be modified/created: `utils/match-storage.js` (core behavior refinements), `tests/match-storage.test.js` (comprehensive acceptance coverage expansion), optional minimal compatibility assertions in `tests/storage.test.js` only if refactor side effects appear.

## Implementation Steps
1. Pre-implementation assumptions check: confirm Task 12 contract in `.taskmaster/tasks/tasks.json` (dependency on Task 11, high priority, acceptance criteria for timestamp/save-load-clear behavior), confirm non-goals (no page wiring changes, no schema redesign), and confirm QA gate command remains `npm run test`.
2. Lock persistence constants/module initialization (subtask 12.1): reuse `STORAGE_KEY` from `utils/match-state-schema.js` as canonical key, preserve the existing `MatchStorage` + `ZeppOsStorageAdapter` structure in `utils/match-storage.js`, and avoid introducing duplicate storage constants or parallel modules.
3. Implement `saveMatchState` timestamp behavior (subtask 12.2): in `utils/match-storage.js`, validate incoming state, update `updatedAt` to `Date.now()` at save time, serialize with existing schema serializer, and persist via adapter `save`; elevated-risk mitigation: keep logic backward-compatible by preserving current method signatures and avoiding adapter contract changes.
4. Harden `loadMatchState` safe-failure flow (subtasks 12.3 and 12.4): ensure load path remains wrapped in explicit defensive handling (adapter read + parse/validation path returns `null` for empty, malformed JSON, or invalid shape), and rely on schema-level validators to enforce full MatchState integrity before returning data.
5. Confirm and keep `clearMatchState` idempotent (subtask 12.5): preserve adapter-based clear semantics (`removeItem` first, `setItem('')` fallback) so clearing is safe both when key exists and when storage is already empty.
6. Expand unit coverage to full Task 12 scenarios (subtask 12.6): update `tests/match-storage.test.js` to explicitly assert timestamp updates during save (deterministic `Date.now` stub/restore), valid round-trip load, null on missing payload, null on corrupted JSON, null on structurally invalid payload, clear-after-save behavior, and clear-on-empty-storage no-throw behavior.
7. Run verification in two passes: first run focused tests (`node --test tests/match-storage.test.js`) for rapid feedback, then run full regression gate (`npm run test`) to ensure no cross-module breakage.
8. Final stabilization and rollback readiness: if regressions appear, rollback only the minimal behavioral delta in `utils/match-storage.js` (timestamp/save-load handling) while retaining Task 11 architecture, then re-apply changes incrementally with failing test-first guidance.

## Validation
- Success criteria: `saveMatchState` persists JSON under canonical storage key and updates `updatedAt`; `loadMatchState` returns a parsed MatchState only when payload is valid and returns `null` for missing/corrupt/invalid payloads; `clearMatchState` removes/invalidates saved session safely and idempotently; unit tests cover valid, missing, corrupt, malformed, and clear flows per Task 12 acceptance.
- Checkpoints: Checkpoint 1 (after step 1) verifies contract, assumptions, and non-goals; Checkpoint 2 (after steps 2-3) verifies canonical key usage and timestamp mutation at save boundary; Checkpoint 3 (after steps 4-5) verifies null-safe load validation and safe clear behavior; Checkpoint 4 (after step 6) verifies all required acceptance tests exist and fail/pass for correct reasons; Checkpoint 5 (after steps 7-8) verifies full-suite regression safety and rollback path if persistence behavior changes affect downstream modules.
