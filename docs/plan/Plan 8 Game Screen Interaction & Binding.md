## Task Analysis
- Main objective: Complete Taskmaster Task 8 (`Game Screen Interaction & Binding`) by finalizing button-to-logic binding on `page/game`, ensuring each tap executes scoring logic, updates visible score state, persists state, and meets the `<100ms` tap-to-update requirement in Zepp OS Mini Program runtime.
- Identified dependencies: Task dependencies `4/5/7` are already done; subtask `8.1` (binding handlers) and subtask `8.2` (auto-save/performance) are defined in `.taskmaster/tasks/tasks.json`; existing interaction and rendering flow lives in `page/game.js`, scoring logic in `utils/scoring-engine.js`, persistence in `utils/storage.js`, and current UI harness patterns in `tests/game-screen-layout.test.js`.
- System impact: Medium, concentrated in Device App page layer and tests: primary edits in `page/game.js` (interaction pipeline + performance checks), plus new/extended integration tests for behavior, persistence, and latency validation; no scoring-rule redesign and no navigation/lifecycle redesign (Task 9 scope).

## Chosen Approach
- Proposed solution: Apply a gap-focused refinement of the current game page interaction path instead of re-architecting: centralize add/remove button handling through one execution wrapper, enforce ordered flow (`logic -> runtime state update -> UI refresh -> saveState`), and add lightweight timing instrumentation around tap-to-render work to verify the 100ms budget.
- Justification for simplicity: Deepthink/brainstorming considered (A) full state-management rewrite with widget diffing (rejected: overengineered for Task 8), (B) immediate partial-widget mutation architecture (rejected as default: higher complexity/risk before proving need), and (C) incremental hardening of the existing full re-render pattern with targeted tests (chosen: smallest change aligned with current code and Zepp page patterns).
- Components to be modified/created: `page/game.js` (final interaction binding flow, autosave ordering, latency measurement guardrails), `tests/game-screen-interaction.test.js` (new focused interaction/persistence/perf tests), `tests/game-screen-layout.test.js` (only minimal updates if shared helpers are needed), and no required changes to `utils/scoring-engine.js` or `utils/storage.js` unless a discovered blocker appears.

## Implementation Steps
1. Pre-implementation assumptions check: confirm Task 8 acceptance scope and that dependencies `4/5/7` are completed; capture non-goals (no new scoring rules, no debounce policy changes from Task 10, no lifecycle/background save work from Task 9).
2. Baseline and file-level strategy lock: review current `page/game.js` handlers (`handleAddPointForTeam`, `handleRemovePointForTeam`, `persistAndRender`) and document the exact delta needed to satisfy Task 8.1/8.2 without changing layout composition from Task 7.
3. Refactor interaction entry points in `page/game.js` into a single internal executor used by all four controls (`+A`, `+B`, `-A`, `-B`) so event binding is uniform and testable.
4. Enforce Task 8 execution order inside the executor: run scoring logic first, validate next state, update app runtime state, trigger UI update immediately, then call `saveState`; preserve no-op behavior when action returns null/unchanged state.
5. Add latency verification hooks in `page/game.js` (tap start/end timing around render path, 100ms threshold constant, non-crashing logging/metrics path) tailored to Zepp OS constraints where direct paint callbacks are limited.
6. Add risk check for long-history interactions (team-specific remove reconstruction): run worst-case interaction sequences in tests/manual scenarios and verify latency remains acceptable; if threshold is exceeded, prepare fallback to targeted score-text widget updates only for hot paths.
7. Implement `tests/game-screen-interaction.test.js` using existing hmUI/Page mocking style: verify each control calls correct scoring branch, updates visible score text, and mutates `app.globalData.matchState` correctly across regular, deuce/advantage, and game-win transitions.
8. Extend persistence verification in tests: assert `saveState`/storage write is invoked after successful scoring actions, and validate state continuity by recreating page/app context and confirming restored scoreboard data.
9. Implement performance checkpoint tests with deterministic clock/mocks for the instrumentation path, and add manual simulator verification instructions for real-device-like latency checks on both `390` and `454` targets.
10. Run QA gate `npm run test`, then perform Zepp simulator smoke validation (square + round) for rapid taps, add/remove correctness, set-score rollover, and resume continuity.
11. Elevated-risk mitigation/rollback note (steps 4-6): if executor refactor introduces regressions, rollback only to pre-refactor handler wiring while retaining added tests; if latency fails on device, keep functional binding and introduce minimal targeted widget updates as a contained follow-up patch.

## Validation
- Success criteria: All four game controls are bound and functional (Task 8.1); each valid tap executes scoring logic, updates on-screen game/set values, and persists state (Task 8.2); measured tap-to-update path stays under 100ms in instrumentation/manual checks; full regression suite passes via `npm run test`.
- Checkpoints: Pre-implementation checkpoint (steps 1-2) confirms scope/dependencies/non-goals; implementation checkpoint A (steps 3-4) confirms deterministic handler binding and correct action ordering; checkpoint B (steps 5-6) confirms latency instrumentation and risk containment; checkpoint C (steps 7-9) confirms automated coverage for interaction, persistence, and performance assertions; post-implementation checkpoint (step 10) confirms QA gate + simulator behavior on round and square screens.
- Acceptance criteria mapping: AC-8.1 Bind Add/Remove controls for both teams -> steps 3, 7; AC-8.2 Execute logic then immediate UI update -> steps 4, 7; AC-8.3 Trigger persistence on score change -> steps 4, 8; AC-8.4 UI update budget under 100ms -> steps 5, 6, 9, 10; PRD AC (`add/remove points`, `view game/set scores`, `state persists across restart`) -> steps 7, 8, 10.
