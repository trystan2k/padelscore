## Task Analysis
- Main objective: Implement Taskmaster Task 5 by adding deterministic `removePoint()` undo behavior that restores the exact previous `MatchState` from history, remains no-op-safe at initial/empty history, and is wired into app/page flow so UI state reflects restored values immediately.
- Identified dependencies: Task 4 is complete and already pushes pre-update snapshots via `addPoint(..., historyStack)` in `utils/scoring-engine.js`; snapshot semantics come from `utils/history-stack.js` (`pop()` returns deep copy or `null`); app runtime already stores `matchState` and `matchHistory` in `app.js`; test harness is Node test runner (`npm run test`).
- System impact: Medium and cross-layer for this stage: scoring engine API expansion (`removePoint`), broader scoring-engine unit coverage (undo + edge scenarios), and lightweight app/page integration updates in `app.js` and `page/index.js` to expose and consume Undo without introducing new architecture.

## Chosen Approach
- Proposed solution: Use history-restore undo (pop previous snapshot and return it as next state) rather than reverse-scoring math; then integrate through app-level action methods that are the only writers to `globalData.matchState`, and trigger page refresh from that single action path.
- Justification for simplicity: Compared three options: (A) reverse rules engine (decrement points/games/sets/tie-breaks), (B) snapshot pop restore, (C) command/event log replay. Reject (A) as fragile and hard to prove for deuce/tie-break/set rollbacks; reject (C) as overengineered for current scope. Choose (B) because Task 4 already created exact pre-update snapshots, so undo becomes small, deterministic, and low-risk.
- Components to be modified/created: `utils/scoring-engine.js` (add/export `removePoint` and validation helpers), `tests/scoring-engine.test.js` (or `tests/remove-point.test.js` if cleaner) for full undo matrix, `app.js` (public score actions and centralized state write path), `page/index.js` (bind Undo handler + refresh from global state).

## Implementation Steps
1. Baseline contract check before edits: confirm Task 5 contract in `.taskmaster/tasks/tasks.json`, verify Task 4 snapshot behavior in `utils/scoring-engine.js` and `utils/history-stack.js`, and lock undo rule assumptions (history-first restore, no-op if empty/initial).
2. Add `removePoint(state, historyStack)` to `utils/scoring-engine.js` with explicit guards: validate `historyStack` exposes `pop`/`isEmpty` (or compatible behavior), return deep-copied current state when undo cannot run, otherwise return popped snapshot as authoritative restored state.
3. Keep no-op behavior deterministic: define `isInitialLikeState(state)` guard for start-of-match (`0-0` points, `0-0` games, set 1 baseline) and ensure remove calls from initial state never mutate history or produce transitions.
4. Preserve invariants and safety in engine-level undo: guarantee returned state keeps score domain validity (`0/15/30/40/'Ad'` or tie-break integers), never negative counters, and no partial field restoration (all of `teamA`, `teamB`, `currentSetStatus`, `currentSet`, `status`, `updatedAt`).
5. Expand unit tests for remove logic in `tests/scoring-engine.test.js` (or split file if readability improves): single undo after point, multi-undo back to initial, empty-history no-op, initial-state no-op, and rapid undo loop safety (repeated calls do not throw or corrupt state).
6. Add restoration-depth tests for critical transitions: undo after deuce/advantage change, undo after game win reset, undo after set transition, and undo inside tie-break progression to verify exact snapshot restoration rather than approximate reverse math.
7. Integrate app-layer Undo action in `app.js`: expose `addPointForTeam(team)` and `removePoint()` wrappers that call scoring engine with `globalData.matchHistory`, then assign the returned snapshot to `globalData.matchState` in one place.
8. Integrate page-layer Undo trigger in `page/index.js`: wire a handler that calls app `removePoint()` action and refreshes rendered score fields from `app.globalData.matchState`; if no explicit Undo button exists yet, still wire handler and view refresh path so upcoming UI widgets can bind without changing business logic.
9. Add a lightweight integration verification path for UI reflection: after simulated add+undo action sequence in page runtime flow, assert displayed values match restored `globalData.matchState` (manual simulator smoke if automated page test harness is unavailable).
10. Run full QA gate `npm run test` and confirm no regressions in existing scoring/history/storage suites before marking Task 5 ready.
11. Risk mitigation and rollback note (elevated risk at cross-layer wiring): if UI integration introduces unstable rendering flow, rollback only `page/index.js` binding changes while preserving validated engine + tests; keep app action API stable so UI can be reattached safely in next iteration.

## Validation
- Success criteria: Undo restores exact previous snapshot across regular, deuce/advantage, game, set, and tie-break states; undo at empty/initial state is a strict no-op; no negative or invalid score transitions occur even under rapid repeated undo; app/page layer reflects restored state immediately after Undo; full test suite passes with `npm run test`.
- Checkpoints: Pre-implementation assumptions check (Task 4 snapshot contract + globalData shape confirmed); during-implementation checkpoint A (engine `removePoint` returns correct snapshot/no-op and preserves invariants); during-implementation checkpoint B (unit tests cover edge and transition-heavy undo scenarios); during-implementation checkpoint C (app/page action path updates one canonical state source and refreshes UI view); post-implementation verification (run `npm run test`), then simulator smoke test for add->undo->rapid undo sequence with visible score parity.
