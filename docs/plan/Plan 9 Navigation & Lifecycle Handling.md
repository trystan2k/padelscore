## Task Analysis
- Main objective: Implement Taskmaster Task 9 (`Navigation & Lifecycle Handling`) so the Game Screen can safely return to Home via Back/Home control while persisting state first, and auto-save state during lifecycle interruptions (pause/hide) to prevent score loss.
- Identified dependencies: Task 6 (Home routing and resume flow) and Task 8 (game interaction + persistence pipeline) are complete; current navigation pattern uses `hmApp.gotoPage` in `page/index.js`; runtime match state and persistence contracts are already established in `page/game.js`, `app.js`, and `utils/storage.js`.
- System impact: Medium and localized to game page control flow plus tests: primary edits in `page/game.js` (navigation button + lifecycle save hooks), minor i18n update in `page/i18n/en-US.po` for Back/Home label, and new/extended tests to verify save-order guarantees and lifecycle-triggered persistence.

## Chosen Approach
- Proposed solution: Use a page-scoped persistence-first navigation design: add a dedicated Game Screen Back/Home button handler that calls a shared save helper before routing to `page/index`, and wire the same save helper to lifecycle hooks (`onHide`, plus `onDestroy` fallback) so interruption events persist the latest runtime match state.
- Justification for simplicity: Deepthink and brainstorming evaluated three options: (A) app-wide event bus and centralized lifecycle broker (rejected: overengineered for one-page scope), (B) app-level pause orchestration in `app.js` only (rejected as sole approach: weaker page-context guarantees and harder ordering tests), and (C) game-page-centric handlers reusing existing `saveState`/runtime patterns (chosen: smallest change, easiest to verify, matches current architecture).
- Components to be modified/created: `page/game.js`, `page/i18n/en-US.po`, `tests/game-screen-navigation-lifecycle.test.js` (or equivalent extension of existing game-page tests), and optionally `app.js` only if a minimal guarded lifecycle fallback is required after implementation discovery.

## Implementation Steps
1. Pre-implementation assumptions check: confirm Task 9 scope from Taskmaster, lock non-goals (no scoring rule changes, no Home screen redesign), and verify dependencies 6/8 behavior is stable in current `page/game.js` and `page/index.js`.
2. Establish a single save entry point in `page/game.js` (for example, `saveCurrentRuntimeState`) that validates runtime state and persists via `saveState`, so navigation and lifecycle hooks share identical persistence behavior.
3. Implement subtask 9.1 navigation control: add a Back/Home widget to Game Screen layout using existing tokenized styling/safe-inset conventions, and bind click flow to `saveCurrentRuntimeState` first, then navigate to Home (`hmApp.goBack` when available, fallback to `hmApp.gotoPage({ url: 'page/index' })`).
4. Add localization string(s) for the new Game Screen navigation control in `page/i18n/en-US.po`, following current key naming (`game.*`) and no hardcoded UI strings.
5. Implement subtask 9.2 lifecycle auto-save hooks in `page/game.js`: call the shared save helper from `onHide`, and add `onDestroy` as a guarded fallback to cover suspend/exit paths where hide ordering can vary.
6. Add correctness guardrails for duplicate save triggers: ensure repeated lifecycle/navigation triggers do not corrupt state or crash (idempotent writes are acceptable), and preserve existing interaction latency flow introduced in Task 8.
7. Add automated coverage for navigation and lifecycle persistence (new test file or focused extension): verify Back/Home button exists, verify click triggers save before navigation, verify lifecycle hook invocation persists exact current score snapshot, and verify no-op behavior when runtime state is invalid/unavailable.
8. Elevated-risk mitigation/rollback note (steps 5-6): if lifecycle hook behavior differs across simulator/device and causes regressions, rollback to the minimal reliable hook (`onHide`) while retaining tests and keeping `onDestroy` fallback behind strict guards for a follow-up patch.
9. Run QA gate `npm run test`, then execute manual simulator checks for round/square targets: play points, trigger Back/Home, resume from Home, simulate background/hide interruption, and confirm state restoration is exact.

## Validation
- Success criteria: Back/Home interaction from Game Screen always saves the latest match state before navigating to Home; lifecycle interruption paths auto-save state reliably; resume flow restores exact score/set state after navigation or backgrounding; existing game scoring/persistence behavior remains intact.
- Checkpoints: Pre-implementation checkpoint (step 1) confirms scope/dependencies/non-goals; implementation checkpoint A (steps 2-4) confirms save-first navigation and UI/i18n correctness; implementation checkpoint B (steps 5-7) confirms lifecycle hook reliability and automated coverage; post-implementation checkpoint (step 9) confirms `npm run test` pass plus simulator validation on both target form factors.
