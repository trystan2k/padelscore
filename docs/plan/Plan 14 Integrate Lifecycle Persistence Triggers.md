## Task Analysis
- Main objective: Implement Task 14 so active match state is persisted through lifecycle interruptions (hide/background/exit) and after every scoring mutation by calling `saveMatchState`, while preserving score continuity on relaunch.
- Identified dependencies: Task 12 persistence APIs in `utils/match-storage.js`; existing game interaction flow and lifecycle hooks in `page/game.js` (`onHide`, `onDestroy`, scoring handlers, `persistAndRender`); existing runtime compatibility path in `utils/storage.js` and `page/index.js`; current test harnesses in `tests/game-screen-layout.test.js`, `tests/home-screen.test.js`, and `tests/match-storage.test.js`; Task 14 subtasks 14.1-14.6 for sequencing.
- System impact: Medium-high in game-page persistence flow and integration tests, medium in documentation, low in unrelated UI; key risks/edge cases to control are duplicate lifecycle triggers (`onHide` + `onDestroy`), scoring plus lifecycle overlap races, pending async save during exit, invalid runtime state no-op behavior, and temporary dual-store consistency during migration (`saveState` legacy plus `saveMatchState` schema).

## Chosen Approach
- Proposed solution: Keep a page-scoped persistence coordinator inside `page/game.js` that (1) receives save requests from scoring and lifecycle triggers, (2) debounces rapid bursts, (3) serializes writes atomically (single in-flight save at a time, latest-state-wins), and (4) provides a forced flush path for lifecycle exit/navigation; wire scoring paths to schedule save immediately after state mutation and wire lifecycle hooks to flush pending state.
- Justification for simplicity: Deepthink + brainstorming considered three options: (A) app-wide event bus and global lifecycle broker (rejected as overengineered for current scope), (B) localized game-page coordinator reusing existing hooks (chosen), and (C) global debounce logic inside `MatchStorage` (rejected now due cross-feature side effects on setup verification flow). Option B is the smallest effective change, aligns with current architecture, and limits regression surface.
- Components to be modified/created: `page/game.js` (primary), `app.js` (optional guarded fallback lifecycle hook only if API discovery confirms value), `tests/game-screen-layout.test.js` (lifecycle/scoring/relaunch persistence scenarios), optional targeted additions in `tests/home-screen.test.js` if resume visibility assertions depend on persisted payload timing, and docs update in `docs/match-state-integration.md` (or task log) for trigger matrix and debounce/atomic behavior notes.

## Implementation Steps
1. [Subtask 14.1] Run a lifecycle hook discovery pass and lock the trigger matrix before code changes: confirm available Zepp OS callbacks in this project context (`Page.onHide`, `Page.onDestroy`, and app-level callbacks such as `App.onDestroy`/`App.onHide` when present), define which hooks are primary vs fallback, and document expected firing order assumptions used by tests.
2. [Subtask 14.2] Refactor game-page persistence entry points in `page/game.js` into explicit methods (schedule, flush, and guarded no-op on invalid state) so all triggers go through one path; keep method signatures stable for existing tests where possible.
3. [Subtask 14.3] Integrate automatic schema persistence after scoring updates: in the scoring success path (`executeScoringAction`/`persistAndRender`), enqueue `saveMatchState` immediately after runtime state mutation (and preserve existing render ordering/performance instrumentation).
4. [Subtasks 14.2 + 14.3] Keep compatibility during migration by using write-through persistence where needed: continue legacy `saveState` behavior until downstream tasks complete migration, and add `saveMatchState` as required source of truth trigger to avoid breaking current resume/runtime flows.
5. [Subtask 14.4] Implement debounced + atomic save execution in the same page module: maintain latest pending snapshot, debounce window (target 100-300ms), single in-flight promise chain, and post-write replay when newer state arrives during an active save; ensure latest-state-wins under rapid taps.
6. [Subtask 14.4] Add forced flush semantics for lifecycle/exit paths (`onHide`, `onDestroy`, back-home flow): when interruption occurs, cancel debounce delay and persist the latest pending/runtime state immediately. Elevated-risk mitigation: if flush timing causes regressions on specific devices, rollback to a stricter `onHide`-first strategy while retaining atomic serialization.
7. [Subtask 14.5] Extend automated integration coverage in `tests/game-screen-layout.test.js` (or a focused sibling file) for: lifecycle hide/destroy persistence, rapid scoring + immediate hide race, single-write coalescing expectations, and relaunch restoration of latest score from persisted state after lifecycle transition.
8. [Subtask 14.5] Add deterministic async test controls for queued saves (for example, explicit drain/idle helper on page instance or awaitable hooks) so tests do not depend on timing flakiness; include edge cases for invalid runtime state and finished-match state behavior.
9. [Subtask 14.6] Update technical documentation/comments to record the final trigger matrix, debounce window rationale, atomic write behavior, and known lifecycle caveats across simulator/device.
10. [Subtasks 14.1-14.6 integration gate] Run focused verification first, then full regression; if failures appear, rollback only the debounce layer first (keep atomic serialization and trigger wiring), then reintroduce debounce with tighter deterministic tests.

## Validation
- Success criteria: lifecycle interruptions always persist the latest valid runtime match state; scoring mutations trigger `saveMatchState` consistently; concurrent trigger bursts do not corrupt state and resolve to latest-state-wins; app relaunch/resume path restores the most recent score snapshot after hide/exit scenarios; and no existing gameplay/navigation tests regress.
- Checkpoints: Pre-implementation assumptions check (after step 1): confirm chosen hooks and non-goals; During-implementation correctness checks (after steps 3-6): run `node --test tests/game-screen-layout.test.js` and targeted persistence cases to verify ordering/race handling; Post-implementation verification and regression checks (after steps 7-10): run `node --test tests/match-storage.test.js`, `node --test tests/home-screen.test.js`, and `npm run test`; optional manual device confidence pass via `zeus dev` (simulator) and `zeus preview` (watch) for sleep/background/exit transitions.
