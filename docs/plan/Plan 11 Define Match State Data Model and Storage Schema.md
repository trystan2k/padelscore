## Task Analysis
- Main objective: Deliver Task 11 (and subtasks 11.1-11.7) by defining a durable MatchState schema for Zepp OS persistence, including defaults, serialization/validation, storage abstraction, schema versioning, migration rules, tests, and integration documentation without destabilizing current gameplay flow.
- Identified dependencies: Inbound dependencies are empty in Taskmaster, but implementation must respect existing modules (`utils/match-state.js`, `utils/storage.js`, `page/index.js`, `page/game.js`) and current Node test harness; downstream Tasks 12, 13, 15, 16, and 18 depend on this contract being stable and migration-safe.
- System impact: Medium-high in domain/persistence utilities and tests, low in UI runtime if implemented additively; primary impact areas are new schema utilities under `utils/`, storage abstraction for `settingsStorage`, migration utilities, targeted unit tests, and integration notes in docs.

## Chosen Approach
- Proposed solution: Use an additive "schema v1" implementation that introduces a dedicated MatchState schema module (types/constants/factory/serialization/validation/migrations) plus a storage service module with an injectable adapter API; keep existing runtime scoring modules intact for now and provide compatibility shims where needed.
- Justification for simplicity: Deepthink + brainstorming considered (A) full in-place replacement of `utils/match-state.js`/`utils/storage.js`, (B) dual-schema rewrite across app/game/scoring now, and (C) additive schema module with phased adoption; (C) is simplest and safest because it satisfies Task 11 acceptance while avoiding a broad refactor before Tasks 12/16 are implemented.
- Components to be modified/created: `utils/match-state-schema.js` (new schema contract), `utils/match-storage.js` (adapter + match storage API), optional compatibility exports in `utils/storage.js` (non-breaking bridge), `tests/match-state-schema.test.js`, `tests/match-storage.test.js`, optional migration-focused tests in `tests/storage.test.js`, and `docs/INTEGRATION.md` (or `docs/match-state-integration.md`) for lifecycle call-point guidance.

## Implementation Steps
1. Phase 0 - Pre-flight assumptions and scope lock: confirm Task 11 parent + 11.1..11.7 requirements from `.taskmaster/tasks/tasks.json`; lock non-goals (no scoring-rule rewrite, no page routing redesign), lock Zepp OS persistence target (`settingsStorage`), and confirm QA gate command remains `npm run test`.
2. Phase 1 - Subtask 11.1 (type/model contract): create `utils/match-state-schema.js` with JSDoc-first type definitions (repo convention with `checkJs`) for `MatchState`, `MatchStatus`, nested set/game structures, and `schemaVersion`; centralize literal unions (`status`, `setsToPlay`, `setsNeededToWin`) as frozen constants to prevent drift.
3. Phase 2 - Subtask 11.2 (factory/constants): implement `createDefaultMatchState()` and constants (`ACTIVE_MATCH_SESSION`, `CURRENT_SCHEMA_VERSION = 1`) returning a fully initialized, serialization-safe object with independent nested references per call.
4. Phase 3 - Subtask 11.3 (serialization + runtime validation): add `serializeMatchState(state)` and `deserializeMatchState(json)` with strict guard functions for enums/ranges/non-negative integers plus malformed JSON handling; return `null` for invalid payloads and keep behavior fail-safe.
5. Phase 4 - Subtask 11.4 (storage adapter abstraction): implement an adapter contract (save/load/clear) and a Zepp-backed adapter using `settingsStorage`, then expose match-focused methods (`saveMatchState`, `loadMatchState`, `clearMatchState`) that always use the schema constants and validation pipeline.
6. Phase 5 - Subtask 11.5 (migration + versioning): implement `migrateMatchState(raw)` with sequential migration registry and explicit handling for legacy v0/no-version payloads; elevated-risk mitigation: if migration input is partially corrupted, short-circuit to `createDefaultMatchState()` instead of attempting partial repair.
7. Phase 6 - Subtask 11.6 (tests): add focused unit tests for factory defaults, no-shared-reference behavior, round-trip serialization, invalid payload rejection, storage adapter save/load/clear flows, and migration transitions (v0->v1, v1 passthrough, invalid version fallback); keep tests deterministic with stubbed `globalThis.settingsStorage`.
8. Phase 7 - Subtask 11.7 (integration docs + dependency mapping): document where to call persistence APIs (after score change, set completion, match finish, lifecycle pause/hide, startup load), map dependency handoff (consumed by Tasks 12/13/16+), and include concise usage examples aligned with existing module import patterns.
9. Phase 8 - Final verification and rollback readiness: run `npm run test`; if regressions appear in existing runtime tests, rollback only compatibility-touching edits (not new additive modules), then re-introduce bridges behind explicit wrappers to preserve backward compatibility.

## Validation
- Success criteria: MatchState schema includes all required PRD fields plus `schemaVersion`; default factory outputs valid state with correct defaults; serializer/deserializer is lossless for valid input and null-safe for invalid input; storage API persists/loads/clears through adapter abstraction; migrations correctly upgrade legacy payloads; and documentation clearly defines integration call points and dependency handoffs.
- Checkpoints: Checkpoint 1 (after step 1) verifies scope/assumptions/non-goals; Checkpoint 2 (after steps 2-3) validates schema/factory contract and constants; Checkpoint 3 (after steps 4-6) validates serialization, adapter behavior, and migration safety; Checkpoint 4 (after steps 7-9) verifies `npm run test` pass, no regression in existing flows, and rollback path for migration or compatibility edge cases.
