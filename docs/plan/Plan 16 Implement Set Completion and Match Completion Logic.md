## Task Analysis
- Main objective: Implement Task 16 by introducing `handleGameWin(team)`-driven set completion and match completion flow so game wins update set-level metadata (`setsWon`, `setHistory`, current-set reset) and mark match completion when `setsNeededToWin` is reached.
- Identified dependencies: Existing point/game engine in `utils/scoring-engine.js` (including tie-break behavior), session schema contract from `utils/match-state-schema.js` (Task 11), persistence orchestration in `page/game.js` (Task 14), set counter rendering added in `page/score-view-model.js` + `page/game.js` (Task 15), and pending Summary destination dependency from Task 18 (`page/summary`).
- System impact: High in scoring-state transitions (set and match boundaries), medium in game-page runtime hydration/navigation/persistence mapping, and medium in regression surface for undo/history and tie-break completion paths.

## Chosen Approach
- Proposed solution: Add a metadata-aware `handleGameWin(team)` path inside `utils/scoring-engine.js` that centralizes post-game progression (increment set games, detect set completion, update `setsWon`/`setHistory`, reset current-set games, and set `status: 'finished'` when threshold reached), then wire `page/game.js` to hydrate runtime state with persisted set config and trigger Summary navigation on the first active->finished transition.
- Justification for simplicity: Deepthink considered (A) full runtime migration to schema-v1 structures across app/page/tests now, (B) incremental augmentation of the existing runtime scoring state with only the set/match metadata required for Task 16, and (C) pushing completion logic into page-layer handlers instead of the engine. Approach B is chosen as the smallest effective change: it reuses current scoring architecture, avoids broad state-manager rewrites, and keeps completion logic close to existing game-win transitions where correctness is easiest to test.
- Components to be modified/created: `utils/scoring-engine.js`, `page/game.js`, `tests/scoring-engine.test.js`, and `tests/game-screen-layout.test.js` (plus any minimal helper updates needed for session-hydration/navigation assertions).

## Implementation Steps
1. Baseline assumptions and guardrails: confirm `team` identifiers remain `teamA|teamB`, match format source remains persisted schema session (`setsNeededToWin` from setup), and tie-break semantics from Task 4 are preserved (set can complete at 7-6 via tie-break path); record non-goal that Task 18 owns Summary screen UI implementation.
2. Implement a scoped metadata-normalization helper in `utils/scoring-engine.js` used by game-win paths to safely read/write `setsNeededToWin`, `setsWon`, and `setHistory` on runtime snapshots without changing external function signatures (`addPoint`/`removePoint`) or breaking legacy states that lack these fields.
3. Introduce `handleGameWin(team)` in `utils/scoring-engine.js` and route both regular-game and tie-break game completion through it: increment team set games, determine set completion (`>=6` and margin `>=2`, with explicit tie-break completion override when applicable), append `{ setNumber, teamAGames, teamBGames }` to `setHistory`, increment `setsWon[winner]`, reset current set games for next set, and set match `status` to `finished` when winner reaches `setsNeededToWin`; if not finished, increment set number and continue. (Elevated risk: tie-break regression at 7-6; mitigation: keep explicit tie-break completion branch and add dedicated tests before merge. Rollback: isolate to new helper branch and temporarily restore previous tie-break finalization while preserving non-tie-break set bookkeeping.)
4. Update `page/game.js` runtime session bridging so validated persisted session data is merged into runtime match state before scoring starts (at minimum `setsNeededToWin`, `setsWon`, current set number/games, and `setHistory`), and ensure persistence snapshot generation writes runtime-owned set/match fields back to schema state instead of stale base-only copies.
5. Add match-completion side effects in `page/game.js` scoring flow: detect first transition from active to finished after a scoring action, force persistence flush, and attempt `hmApp.gotoPage({ url: 'page/summary' })`; if navigation fails (Task 18 not yet present), keep the finished game screen state stable as fallback. (Elevated risk: premature navigation before persistence completion; mitigation: force flush and transition guard. Rollback: disable auto-navigation while retaining finished-state mutation and persistence if regressions appear.)
6. Expand `tests/scoring-engine.test.js` with deterministic sequences that validate: set win increments `setsWon`, pushes `setHistory`, and resets current set games; non-winning game states do not mutate set history; match reaches `finished` exactly at configured `setsNeededToWin` thresholds (1/2/3); and tie-break set completion records `7-6` style history correctly.
7. Expand `tests/game-screen-layout.test.js` integration coverage for Task 16: verify runtime hydration uses persisted match format metadata, verify finished transition attempts Summary navigation, confirm scoring controls are no longer available after completion state, and verify persisted writes include updated `status`, `setsWon`, and `setHistory` payloads.
8. Execute validation in layers: run focused suites first (`node --test tests/scoring-engine.test.js` and relevant Task 16 game-page tests), then run full QA gate `npm run test`; triage regressions prioritizing scoring correctness and persistence consistency over UI polish.

## Validation
- Success criteria: `handleGameWin(team)` updates set and match metadata correctly; set wins append accurate set-history entries and reset current set games; match flips to `finished` only when `setsWon[winner] >= setsNeededToWin`; finished transition persists state and initiates Summary navigation attempt; existing deuce/advantage/tie-break/undo behavior remains regression-free.
- Checkpoints: Pre-implementation assumptions check (after Step 1) confirms metadata sources, tie-break handling, and Task 18 boundary; during-implementation correctness checks (after Steps 3-5) validate set/match transitions, runtime hydration, and active->finished navigation trigger with targeted tests; post-implementation verification (after Steps 6-8) requires passing focused scoring+game integration tests and the full `npm run test` suite, with rollback scoped to new completion/navigation branches if instability is detected.
