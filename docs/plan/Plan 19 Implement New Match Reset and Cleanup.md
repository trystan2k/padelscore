## Task Analysis
- Main objective: Implement Task 19 (subtasks 19.1-19.5) by introducing reusable reset primitives (`clearActiveMatchSession`, `resetMatchStateManager`) and a single `startNewMatchFlow` orchestrator, then wiring Summary and Home reset entry points so a new match always starts from a clean persisted + in-memory state.
- Identified dependencies: Existing persistence APIs in `utils/match-storage.js` (`clearMatchState`) and `utils/storage.js` (`clearState`) must remain dual-cleared during migration; runtime manager conventions in `app.js` (`globalData.matchState`/`globalData.matchHistory`) and page-level reset patterns in `page/index.js` and `page/summary.js`; setup navigation contract (`hmApp.gotoPage({ url: 'page/setup' })`) used by Home/Summary/Game; current test harness import-rewrite patterns in `tests/home-screen.test.js` and `tests/summary-screen.test.js` plus utility test style in `tests/match-storage.test.js`.
- System impact: Medium-high on session lifecycle correctness (stale finished/active sessions must never bleed into new match), medium on Home/Summary behavior because duplicate reset logic is consolidated, low on scoring logic/UI rendering because no scoring engine rule changes are required.

## Chosen Approach
- Proposed solution: Add a focused utility module (single source of truth) exporting `clearActiveMatchSession`, `resetMatchStateManager`, and `startNewMatchFlow`; keep behavior best-effort and idempotent; replace page-local reset logic in `page/summary.js` and `page/index.js` with orchestrator calls; formalize Home hard reset capability by routing Home's Start action through the same orchestrator contract (with an explicit hard-reset handler alias so the capability is codified without risky layout expansion).
- Justification for simplicity: Deepthink/brainstorming comparison favored this over (A) keeping duplicated page reset implementations (rejected: drift risk and repeated bug surface) and (B) moving orchestration into `app.js` global methods (rejected: broader coupling and larger regression radius). A utility module is the smallest safe change that centralizes semantics, preserves current UX, and is easy to unit test in isolation.
- Components to be modified/created: `utils/start-new-match-flow.js` (new orchestrator + utilities), `page/summary.js` (replace local reset path), `page/index.js` (replace local start/reset path and codify Home hard-reset entry), `tests/start-new-match-flow.test.js` (new), `tests/home-screen.test.js` (update expectations/import rewrites and hard-reset coverage), `tests/summary-screen.test.js` (update import rewrites and orchestrator-driven assertions), and `docs/match-state-integration.md` (small contract update for canonical reset flow).

## Implementation Steps
1. Lock assumptions before edits: confirm reset semantics remain dual-store (`clearState` + `clearMatchState`) until legacy storage migration is complete; confirm navigation target remains `page/setup`; define non-goals (no changes to scoring engine, setup initialization logic, or summary rendering layout).
2. Implement `clearActiveMatchSession` utility (Task 19.1) in a new flow module: call schema clear + legacy clear in one idempotent function, swallow storage adapter failures, and return a structured result (`{ clearedSchema, clearedLegacy }`) for testability. Elevated risk: partial clear if one backend fails; mitigation: independent best-effort clears and explicit result flags; rollback: revert to prior inline clear calls while keeping function scaffold for future retry logic.
3. Implement `resetMatchStateManager` utility (Task 19.2): resolve app instance safely, reset `globalData.matchState` via `createInitialMatchState()`, clear existing history when available, otherwise rehydrate with `createHistoryStack()`, and return a boolean/result object. Elevated risk: mutating unexpected app shape in tests/runtime; mitigation: strict object guards and no-op fallback; rollback: preserve existing page-local reset methods if manager mutation regressions appear.
4. Implement `startNewMatchFlow` orchestrator (Task 19.3): sequence `clearActiveMatchSession` -> `resetMatchStateManager` -> navigate to setup, wrap in try/catch, and provide dependency injection hooks (storage reset, manager reset, navigate) so tests can validate ordering and failure branches deterministically.
5. Wire Summary `Start New Game` button (Task 19.4): replace `page/summary.js` inline reset logic (`clearState`, `clearMatchState`, page-local manager reset) with `startNewMatchFlow`; keep current button UX and route unchanged; remove duplicate helpers that become dead code.
6. Add Home hard reset capability with minimal UI risk (Task 19.5): route Home Start action through `startNewMatchFlow` as the canonical hard-reset path, add an explicit Home hard-reset handler alias (internally same orchestrator call) so emergency reset behavior is intentional/documented without adding a third button that could break compact watch layouts.
7. Add/update automated tests: create `tests/start-new-match-flow.test.js` for utility/orchestrator behavior (success path, partial-clear failure tolerance, manager reset, navigation call order); update `tests/home-screen.test.js` and `tests/summary-screen.test.js` import-rewrite stubs for the new utility import and assert both screens now rely on orchestrator-equivalent outcomes.
8. Run validation and regression gate: execute focused suites first (`node --test tests/start-new-match-flow.test.js tests/home-screen.test.js tests/summary-screen.test.js`), then full gate (`npm run test`), and update `docs/match-state-integration.md` reset section to point to `startNewMatchFlow` as canonical entry.

## Validation
- Success criteria: `clearActiveMatchSession` clears persisted active session data safely (including migration-era legacy key), `resetMatchStateManager` restores runtime manager to initial state and emptied history, `startNewMatchFlow` performs cleanup then setup navigation in order, Summary `Start New Game` triggers orchestrator cleanup flow, and Home exposes/calls the same hard-reset-capable flow without regressing existing Resume behavior.
- Checkpoints: Pre-implementation checkpoint (after Step 1) verifies assumptions/non-goals and confirms no UI layout expansion is required; implementation checkpoint A (after Steps 2-4) requires passing new utility tests for happy/error-ordering paths; implementation checkpoint B (after Steps 5-7) requires Home/Summary behavior tests to pass with unchanged visible button contract; post-implementation checkpoint (after Step 8) requires full `npm run test` pass and docs sync. Rollback trigger: if navigation/reset regressions appear, immediately revert page wiring to prior inline reset methods while retaining tested utility module for staged re-integration.