## Task Analysis
- Main objective: Complete Task 10 by refining Game Screen visuals to match Lovable references (including finish-state presentation), enforcing sports-usable touch targets (>=48x48), and adding a 300ms debounce on scoring interactions without breaking the <100ms UI update budget for accepted taps.
- Identified dependencies: Task 9 is done (save-before-navigation and lifecycle persistence), Task 8 already centralizes scoring through `executeScoringAction` in `page/game.js`, visual references live in `docs/images/*.png` and `docs/PRD.md`, and current behavioral/performance harness exists in `tests/game-screen-layout.test.js`.
- System impact: Medium and localized; primary impact in `page/game.js` (design tokens, finish-state styling branch, debounce gate, touch-target sizing), optional i18n additions in `page/i18n/en-US.po`, and focused test expansion in `tests/game-screen-layout.test.js` (or a sibling game-polish test file if separation improves readability).

## Chosen Approach
- Proposed solution: Use a single-page incremental polish strategy: keep architecture unchanged, refine existing `GAME_TOKENS` and widget props, add a lightweight finish-state rendering variant keyed from `matchState.status`, and add timestamp-based debounce inside the existing scoring executor path so accepted taps still follow the current `update -> render -> save` flow.
- Justification for simplicity: Deepthink + brainstorming compared (A) new dedicated finish page with routing/state orchestration, (B) app-level global input lock middleware, and (C) targeted enhancement of existing game-page rendering/handlers; (C) is chosen because it minimizes surface area, reuses tested control flow, and avoids overengineering for a polish task.
- Components to be modified/created: `page/game.js` (style tokens, button sizing floor, finish-style conditional, debounce window constant and guard), `page/i18n/en-US.po` (only if new finish label keys are needed), `tests/game-screen-layout.test.js` (extend current hmUI harness for touch-target, debounce, and finish-style assertions), and `docs/plan/Plan 10 Styling Refinement, Input Debouncing & Polish.md` (this plan).

## Implementation Steps
1. Pre-implementation assumptions checkpoint: confirm Task 10 scope/non-goals from `.taskmaster/tasks/tasks.json` (no scoring-rule rewrite, no new navigation flow, no full page architecture changes), and lock performance target (<100ms for accepted scoring taps) plus QA gate (`npm run test`).
2. File discovery strategy: map all style and interaction touchpoints via focused scans of `page/game.js` (`GAME_TOKENS`, button dimensions, `renderGameScreen`, `executeScoringAction`, scoring handlers), `docs/PRD.md` + `docs/images/*` (Lovable alignment points), and `tests/game-screen-layout.test.js` (existing widget/perf assertions to extend instead of duplicating harnesses).
3. Styling change strategy (Task 10.1): refine token values and widget properties in `page/game.js` to match final design intent (score emphasis colors, button normal/press contrast, finish-state visual treatment), while preserving current round/square safe-area math and top-to-bottom section hierarchy.
4. Accessibility sizing strategy (Task 10.1): enforce minimum interactive dimensions by raising button floors to >=48 and validating all scoring/navigation controls satisfy >=48x48 across 390x450, 390x390, and 454x454 test scenarios.
5. Finish-state polish strategy (Task 10.1): add a minimal conditional rendering branch for `viewModel.status === 'finished'` (text/color treatment and scoring-control behavior) without introducing new routes; if needed, add i18n keys with existing `game.*` naming convention.
6. Debounce change strategy (Task 10.2): add a 300ms guard inside the shared scoring execution path (`executeScoringAction` or equivalent internal gate) so accepted scoring taps set a last-accepted timestamp and subsequent taps inside the window are ignored without mutating state, rerendering, or saving.
7. During-implementation correctness checkpoint: add/extend automated tests to prove (a) control touch targets are >=48x48, (b) rapid repeated scoring taps inside 300ms produce exactly one state transition, (c) taps after debounce window are accepted, (d) existing performance metrics still report <100ms for accepted interactions.
8. Post-implementation validation strategy: run `npm run test`, then perform manual simulator audit against Lovable images on both target form factors (gts-3 and gtr-3 design widths) for color/style fidelity, finish-state readability, and rapid-tap behavior during real interaction.
9. Elevated-risk mitigation and rollback note: if debounce timing introduces regressions (missed intentional taps or broken tests), rollback only the debounce guard while keeping style/accessibility changes; if finish-state styling conflicts with current match-flow assumptions (status rarely set), keep branch behind existing status check with no scoring-engine changes and schedule follow-up once match-completion rules are explicitly finalized.

## Validation
- Success criteria: Game Screen visuals align with Lovable references (including finish-state presentation), all interactive controls meet >=48x48 touch target minimum, scoring handlers enforce a 300ms debounce against accidental double scoring, accepted tap interactions remain under 100ms in test instrumentation/manual verification, and the full test suite passes via `npm run test`.
- Checkpoints: Checkpoint 1 (steps 1-2) confirms assumptions and discovery completeness; Checkpoint 2 (steps 3-5) verifies design/accessibility deltas are implemented without layout regressions; Checkpoint 3 (steps 6-7) verifies debounce correctness and performance budget on accepted taps; Checkpoint 4 (steps 8-9) verifies QA gate pass, simulator visual audit, and rollback readiness for high-risk edge cases.
