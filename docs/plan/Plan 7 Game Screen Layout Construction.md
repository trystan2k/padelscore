## Task Analysis
- Main objective: Implement Taskmaster Task 7 by structuring `page/game` into a clear top/middle/bottom game layout: top Set Scores, middle large Current Game Points, and bottom Team A/Team B Add/Remove controls that stay readable on watch screens.
- Identified dependencies: Task definition in `.taskmaster/tasks/tasks.json`; existing page lifecycle/render pattern in `page/game.js` and `page/index.js`; score data contract from `page/score-view-model.js`; target constraints in `app.json` (`gtr-3` and `gts-3` design widths); i18n labels in `page/i18n/en-US.po`; Node test harness style in `tests/home-screen.test.js`.
- System impact: Medium and mostly isolated to UI composition in `page/game.js` (layout math + widget tree), with likely small i18n additions for remove labels and optional new page-layout tests; no scoring rule or persistence contract changes are required for this task.

## Chosen Approach
- Proposed solution: Refactor `renderGameScreen()` to a sectioned, metrics-driven layout with explicit vertical zones (`setScoreSection`, `pointsSection`, `controlsSection`) computed from screen dimensions, then render each zone with high-contrast typography and bottom controls in a 2x2 Add/Remove grid (Team A and Team B).
- Justification for simplicity: Three approaches were evaluated in deepthink and brainstorming: (A) keep the current single-card composition and tweak offsets (rejected: fragile on round screens and hard to validate for cutoff), (B) use a sectioned vertical allocator with bounded scales and safe insets (chosen: smallest change that gives deterministic placement across round/square), (C) create per-device hardcoded coordinates (rejected: duplicated logic and high maintenance).
- Components to be modified/created: `page/game.js` (primary layout refactor), `page/i18n/en-US.po` (Add/Remove labels if missing), `tests/game-screen-layout.test.js` (new responsive layout assertions with hmUI mocks), and no changes to `utils/scoring-engine.js` unless integration blockers are discovered.

## Implementation Steps
1. Perform a pre-implementation assumptions check: confirm Task 7/subtask acceptance criteria in `.taskmaster/tasks/tasks.json`, verify current `page/game.js` responsibilities, and lock non-goals (no scoring algorithm changes; layout-first scope).
2. Baseline current geometry and constraints: record existing widget layout behavior for representative square (`390x450`) and round-like (`454x454`) simulator profiles to establish what currently overlaps/crops.
3. Introduce a dedicated layout-metrics helper inside `page/game.js` (or nearby private functions) that computes safe insets, section heights, and min/max font/button sizes from `{ width, height }` before any widget creation.
4. Implement subtask 7.1 (Set Score section): render a top section showing both teams' set/game score values with clear left-right alignment, high-contrast colors, and section spacing independent of the middle card.
5. Implement subtask 7.2 (Current Game Point section): render a center section with the current point score as the dominant visual element (large text with bounded scaling), preserving readability at smaller heights.
6. Implement subtask 7.3 controls layout: create bottom Team A/Team B Add/Remove controls in a responsive 2x2 grid, keeping touch-friendly button heights and consistent horizontal gaps.
7. Add responsive adaptation guards: apply round-screen edge safety (extra side inset/corner reserve), overflow checks, and progressive downscaling rules so top/middle/bottom zones never intersect.
8. Keep interaction continuity while staying in Task 7 scope: wire controls to existing page handlers where already available; if team-specific remove behavior is not yet finalized, keep layout-complete controls with temporary safe fallback wiring that Task 8 can finalize.
9. Update i18n resources for control labels (`+`/`-` team actions) to avoid hardcoded strings and preserve existing localization pattern in `page/i18n/en-US.po`.
10. Add/extend automated UI-structure checks (new `tests/game-screen-layout.test.js`): assert section ordering (top < middle < bottom), button presence/count, and that all widget bounds remain inside screen dimensions for square and round-like metrics.
11. Run QA gate `npm run test`, then perform simulator visual verification on round and square targets to confirm no overlap/cutoff and readable typography for set and point values.
12. Risk mitigation and rollback note (elevated risk in steps 6-7): if the 2x2 bottom controls cause clipping on round profiles, rollback only the new controls geometry to a stacked compact variant while keeping completed top/middle sections and tests intact.

## Validation
- Success criteria: `page/game` displays top set scores for both teams, middle current game points in clearly larger typography, and bottom Team A/Team B Add/Remove controls; all widgets remain fully visible on round and square simulator targets with no overlap/cutoff; automated tests pass via `npm run test`.
- Checkpoints: Pre-implementation checkpoint (step 1) confirms scope/non-goals and dependencies; implementation checkpoint A (steps 3-5) confirms stable top/middle layout sections; checkpoint B (steps 6-7) confirms responsive controls and non-overlap rules on both form factors; checkpoint C (steps 8-10) confirms wiring continuity, i18n completeness, and structural test coverage; post-implementation checkpoint (step 11) confirms QA gate and simulator visual acceptance, with fallback path from step 12 if round-screen clipping appears.
