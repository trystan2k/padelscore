## Task Analysis
- Main objective: Implement Task 13 by introducing a dedicated pre-match setup flow where users select 1/3/5 sets, initialize a valid active match session, persist it before leaving setup, and only then enter the game.
- Identified dependencies: Task 11 schema contract (`utils/match-state-schema.js`) and Task 12 persistence APIs (`utils/match-storage.js`) are already done; current runtime/navigation patterns in `page/index.js`, `page/game.js`, `app.json`, and existing page-test harnesses in `tests/home-screen.test.js` and `tests/game-screen-layout.test.js` must be preserved.
- System impact: Medium-high across page routing and access control (`app.json`, `page/index.js`, new setup page, `page/game.js` guard), plus medium impact in tests due async persistence/guard flow and new setup scenarios.

## Chosen Approach
- Proposed solution: Add a dedicated `Match Setup` page with explicit set selection + `Start Match` confirmation, implement a small `initializeMatchState(setsToPlay)` utility based on schema defaults, persist via `saveMatchState` with read-after-write verification, route Home `Start New Game` to setup, and guard Game access using `loadMatchState` active-session validation before rendering gameplay.
- Justification for simplicity: Deepthink + brainstorming considered (A) embedding setup UI into Home, (B) full immediate migration of all gameplay runtime/state modules to schema v1, and (C) isolated setup page + focused guard + minimal compatibility handling; (C) is the simplest effective path because it satisfies acceptance criteria now without a high-risk scoring-engine refactor.
- Components to be modified/created: `app.json` (register setup route for both targets), `page/index.js` (start flow to setup), `page/game.js` (active-session guard + redirect), `page/setup.js` (new setup UI/logic), `utils/match-session-init.js` or equivalent initializer helper (new), `page/i18n/en-US.po` (setup labels/errors), and tests (`tests/home-screen.test.js`, new setup tests, game guard coverage).

## Implementation Steps
1. Pre-implementation assumptions check: confirm Task 13 scope/subtasks in `.taskmaster/tasks/tasks.json`, lock non-goals (do not rewrite scoring engine to schema in this task), and lock QA command (`npm run test`) so implementation remains acceptance-focused.
2. Create a focused state-initialization helper (subtask 13.2): add `initializeMatchState(setsToPlay)` that accepts only 1/3/5, computes `setsNeededToWin` with `Math.ceil(setsToPlay / 2)`, and returns a fresh schema-valid active state (zeroed scores, empty history, current timestamps) by reusing `createDefaultMatchState` shape to avoid model drift.
3. Build Match Setup page UI (subtask 13.1): add a new page module with three set-selection controls (1/3/5), visible selected state, and a `Start Match` button that is visually and behaviorally disabled until selection exists; follow current widget/token layout conventions used in `page/index.js` and `page/game.js`.
4. Implement persistence-before-navigation flow (subtasks 13.3 and 13.4): in setup confirm handler, prevent duplicate submissions, initialize state, call `saveMatchState`, then immediately call `loadMatchState` to verify the saved session is present/active; only navigate to `page/game` when verification succeeds, otherwise surface inline/toast-style error text and keep user on setup. Risk mitigation: keep persistence + verification in a single helper returning boolean success so rollback is localized if async behavior causes regressions.
5. Wire navigation entry points and routes: update Home `handleStartNewGame` to navigate to setup instead of direct game entry, keep `Resume` flow unchanged for now, and register the new setup page route in both `gtr-3` and `gts-3` page arrays in `app.json`.
6. Add game access control guard (subtask 13.5): in `page/game.js`, add an early active-session check on show/init using `loadMatchState`; if missing/invalid/non-active, redirect to setup and skip gameplay render/update path for that cycle. Elevated-risk mitigation: encapsulate guard logic in one method (e.g., `hasValidActiveSession`) and keep temporary compatibility fallback behavior explicit and removable in later migration tasks if legacy-runtime interactions surface.
7. Add/adjust localization and UX messaging: introduce setup-related i18n keys (title, option labels, start button, save failure message) and ensure button labels/errors match existing gettext conventions.
8. Implement test coverage (subtask 13.6):
   - Unit tests for `initializeMatchState` across 1/3/5 sets and invalid input handling.
   - Integration-style setup-page tests validating selection UX, disabled start without selection, persistence-before-navigation ordering, and no navigation on failed verification.
   - Game guard tests validating redirect to setup when no valid active persisted session and allow-render path when valid session exists.
   - Update existing home-screen expectation from `page/game` to setup route for new-match button.
9. Run validation sequence and stabilize: execute focused tests first (new/updated suites), then `npm run test`; if failures concentrate around guard timing, rollback only guard invocation timing (not setup/persistence core) and reapply with deterministic lifecycle ordering.

## Validation
- Success criteria: selecting 1/3/5 sets creates a correctly initialized active session (`setsToPlay`, `setsNeededToWin`, zeroed scores/history); `Start Match` does not navigate without valid selection; persistence is confirmed before navigation; game page access is blocked and redirected when no valid active state exists; and automated tests cover happy path + failure/guard paths.
- Checkpoints: Checkpoint 1 (after steps 1-2) confirms initialization helper outputs schema-valid states for all allowed set counts; Checkpoint 2 (after steps 3-4) confirms setup UX state transitions and save-then-verify-before-navigate order; Checkpoint 3 (after steps 5-6) confirms new route wiring and guard redirect behavior on missing/invalid session; Checkpoint 4 (after steps 7-8) confirms i18n coverage plus unit/integration tests for all subtasks; Checkpoint 5 (after step 9) confirms full regression pass and documented rollback scope for guard-related risk.
