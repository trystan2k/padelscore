## Task Analysis
- Main objective: Implement Task 15 by updating the Game Screen so match-level set counters (`setsWon.teamA`, `setsWon.teamB`) are clearly visible next to existing live score information and refresh immediately when underlying state changes.
- Identified dependencies: Task 11 schema contract (`utils/match-state-schema.js`) for `setsWon`; current game rendering/persistence flow in `page/game.js`; current view-model mapping in `page/score-view-model.js`; existing UI/layout regression harness in `tests/game-screen-layout.test.js`; i18n labels in `page/i18n/en-US.po`; Task 15 subtasks 15.1-15.6 for sequencing.
- System impact: Medium in `page/game.js` layout geometry and render widgets, low-medium in view-model and i18n label additions, medium in test harness updates because numeric score selectors will need disambiguation once additional numeric widgets are added; no `app.json` route/module/API-level changes expected.

## Chosen Approach
- Proposed solution: Add a small, explicit "sets won" display band in the existing top score card (Game Screen) and source its values from a normalized view-model field (`setsWon`) that prefers runtime state and safely falls back to persisted session/default zeros; re-render path remains the existing `renderGameScreen()` lifecycle/scoring flow.
- Justification for simplicity: Deepthink + brainstorming considered three options: (A) full migration of runtime scoring state to schema-v1 everywhere before UI work (rejected as overengineering for Task 15), (B) localized UI/data mapping updates in game page + view model + tests (chosen), and (C) display-only read from persisted storage without runtime binding (rejected because programmatic in-memory updates would not render immediately). Option B is the smallest change that satisfies acceptance and preserves current architecture.
- Components to be modified/created: `page/game.js` (layout + widgets + binding hookup), `page/score-view-model.js` (add `setsWon` mapping/fallback contract), `page/i18n/en-US.po` (set counter label text if needed), `tests/game-screen-layout.test.js` (new assertions + helper refinement for distinct counters), and optional note update in `docs/match-state-integration.md` to document Task 15 UI consumption of `setsWon`.

## Implementation Steps
1. [Subtask 15.1] Lock scope and layout insertion point: inspect current top card metrics in `page/game.js` (`setSectionHeight`, label/value rows, round-screen safe inset logic) and confirm non-goals (do not implement set-win/match-win logic from Task 16).
2. [Subtask 15.1] Define the minimal data contract for display: standardize a `setsWon` read path used by Game Screen (runtime `matchState.setsWon` first, then persisted-session fallback, then `{teamA:0, teamB:0}`) so entry and programmatic updates behave deterministically.
3. [Subtask 15.2] Add UI elements in the top score section for Team A/Team B sets won counters (and optional short label) with placement that preserves existing hierarchy: team labels -> set counters -> current-set games, while maintaining square/round safe-area constraints.
4. [Subtasks 15.3 + 15.4] Bind the new widgets to the normalized `setsWon` values in the render path and ensure all existing rerender triggers (scoring actions, lifecycle-driven render, explicit `renderGameScreen()` calls) update these counters without introducing new observers/state engines.
5. [Subtask 15.4, elevated risk] Ensure programmatic state mutation path is reflected immediately (<=100ms target): verify that changing `app.globalData.matchState.setsWon` followed by render updates text in the same frame cycle. Mitigation/rollback: if binding introduces instability, temporarily keep fallback-only read in isolated helper and revert only new binding logic while preserving UI widgets.
6. [Subtask 15.5] Apply styling using existing game tokens (accent/muted/text colors and proportional font sizes) and tune vertical spacing so no overlap occurs across 390x450, 390x390, and 454x454 layouts.
7. [Subtask 15.6] Update/extend `tests/game-screen-layout.test.js`: add assertions that set counters are visible and initialized to `0` on entry; add programmatic update assertions for independent Team A/Team B changes; refine score-text helpers so current-set game checks remain robust after adding more numeric text widgets.
8. [Subtask 15.6] Run focused verification on updated game-screen tests first, then run full regression (`npm run test`) to ensure no breakage in persistence, setup flow, or existing game interactions.
9. [Subtask 15.6] Document final behavior and risk boundaries (brief task log or integration note) including explicit statement that set increment logic itself is still owned by Task 16.

## Validation
- Success criteria: Game Screen shows both sets-won counters on initial entry with `0-0`; counters are bound to match state and reflect programmatic `setsWon` changes immediately; existing set-games and game-points displays remain correct; layout remains in-bounds on round and square targets; full test suite remains green.
- Checkpoints: Pre-implementation assumptions check (after steps 1-2) confirms insertion point, data-source precedence, and non-goals; During-implementation correctness checks (after steps 3-6) confirm widget placement, styling, and immediate update behavior with targeted game-screen tests; Post-implementation verification and regression checks (after steps 7-9) run `node --test tests/game-screen-layout.test.js` then `npm run test`, with rollback scope limited to new sets-won binding layer if regressions occur.
