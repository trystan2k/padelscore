{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Project Initialization & Configuration",
        "description": "Set up the Zepp OS project structure, configuration files, and base directories.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Initialize a new Zepp OS Mini Program project. Configure `app.json` with the project ID, version, and necessary permissions (e.g., storage). Set up the folder structure (pages, utils, assets). Ensure the project is configured to support both round and square screen resolutions by defining viewport settings or using responsive units (px/rpx).",
        "testStrategy": "Verify the project compiles successfully using the Zepp developer tools. Confirm that the app launches on the simulator (round and square) without crashing and displays a blank page or default index.",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Zepp OS Project and Directory Structure",
            "description": "Create the base project using the CLI and establish the folder scaffolding.",
            "dependencies": [],
            "details": "Execute the Zepp OS project initialization command to generate the boilerplate. Manually create the required directory structure including folders for 'pages', 'utils', and 'assets' to organize the codebase.",
            "status": "done",
            "testStrategy": "Verify that the project command executes without errors and all required folders exist in the file system.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.785Z"
          },
          {
            "id": 2,
            "title": "Configure Core App Metadata in app.json",
            "description": "Set the project identification and version information in the configuration file.",
            "dependencies": [
              1
            ],
            "details": "Edit the root `app.json` file to input the correct `appId`, `versionName`, `versionCode`, and `appName`. Ensure the JSON syntax is valid to prevent build errors.",
            "status": "done",
            "testStrategy": "Validate the JSON structure using a linter or the Zepp developer tools to ensure no syntax errors exist.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.791Z"
          },
          {
            "id": 3,
            "title": "Define Storage Permissions in app.json",
            "description": "Configure necessary permissions for local data access.",
            "dependencies": [
              2
            ],
            "details": "Add the appropriate permission keys to `app.json` to enable access to `storage` APIs. This is required for the subsequent implementation of local state persistence.",
            "status": "done",
            "testStrategy": "Review the configuration file to confirm permission keys are present and formatted according to Zepp OS documentation.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.794Z"
          },
          {
            "id": 4,
            "title": "Set Viewport Configuration for Round Screens",
            "description": "Configure the project settings to support circular screen resolutions.",
            "dependencies": [
              2
            ],
            "details": "Update the `app.json` or global configuration files to define the `designWidth` and viewport settings specifically tailored for round screen devices (e.g., 454px). Configure the design system to handle circular clipping zones.",
            "status": "done",
            "testStrategy": "Deploy the project to a round screen simulator and verify that the default page renders within the circular bounds without overflow.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.795Z"
          },
          {
            "id": 5,
            "title": "Set Viewport Configuration for Square Screens and Responsive Units",
            "description": "Ensure compatibility with square screens and implement responsive units.",
            "dependencies": [
              4
            ],
            "details": "Adjust configuration to support square screen resolutions. Enforce the use of responsive units (px/rpx) in the global settings or style guide to ensure layouts scale correctly across both round and square form factors.",
            "status": "done",
            "testStrategy": "Deploy to a square screen simulator. Verify elements are positioned correctly and that the layout adapts without distortion compared to the round screen view.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.797Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break this task down into subtasks covering: 1) Project creation and folder scaffolding, 2) Configuration of app.json (permissions, project ID), and 3) Viewport setup for round and square screens.",
        "updatedAt": "2026-02-20T07:17:14.797Z"
      },
      {
        "id": "2",
        "title": "Data Model & State Management Design",
        "description": "Define the data structures for the game state, scoring history, and team configurations.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Create JavaScript/TypeScript interfaces for `MatchState` including: Team A/B scores (points, games), current set status, and match status (active/finished). Implement a history stack structure to store past states for the Undo functionality (as per 'Option 2' state machine approach). Define constants for scoring sequences (0, 15, 30, 40, Ad, Game).",
        "testStrategy": "Unit tests to verify that the state object initializes correctly with zero values and that the history stack can push and pop deep copies of the state without reference errors.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interfaces for Game Entities",
            "description": "Create TypeScript interfaces for MatchState, Team configurations, and status enumerations to type-check the game data.",
            "dependencies": [],
            "details": "Define `MatchState` interface including properties for Team A/B scores (points, games), current set status, and match status (active/finished). Create supporting types for TeamScore if necessary.",
            "status": "done",
            "testStrategy": "Unit tests to verify interfaces compile correctly and accept valid data shapes for match initialization.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:11.492Z"
          },
          {
            "id": 2,
            "title": "Implement History Stack with Deep Copy Logic",
            "description": "Develop the history stack data structure required for the Undo functionality, ensuring immutability via deep copying.",
            "dependencies": [
              1
            ],
            "details": "Implement a stack class or module with `push(state)` and `pop()` methods. Integrate deep copy logic (e.g., using JSON.parse(JSON.stringify()) or a utility library) to ensure stored states are independent snapshots.",
            "status": "done",
            "testStrategy": "Unit tests to verify that pushing a state and modifying the original does not affect the stored history, and that pop correctly restores previous states.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:13.045Z"
          },
          {
            "id": 3,
            "title": "Define Scoring Constants and Enumerations",
            "description": "Establish the standard scoring sequences and domain constants used throughout the scoring logic.",
            "dependencies": [],
            "details": "Define constants for the scoring sequence (0, 15, 30, 40, Ad, Game). Create enumerations for game phases or specific states to ensure type safety in the scoring engine.",
            "status": "done",
            "testStrategy": "Validation to ensure constant values match standard Padel/Tennis scoring rules and are accessible for import by other modules.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:14.673Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1) Defining TypeScript interfaces for MatchState and related entities, 2) Implementing the history stack structure with deep copy logic, and 3) Defining scoring constants and enumerations.",
        "updatedAt": "2026-02-20T13:23:14.673Z"
      },
      {
        "id": "3",
        "title": "Local Storage & Persistence Layer",
        "description": "Implement the mechanism to save and load the game state using the device's local storage.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "Utilize Zepp OS `settingsStorage` API to persist the `MatchState` object as a JSON string. Implement `saveState(state)` and `loadState()` functions. Ensure data is serialized correctly and handle potential JSON parsing errors. The load function should return `null` if no saved game exists.",
        "testStrategy": "Manually save a state, restart the app/simulator, and verify the data is retrieved accurately. Test with invalid/corrupted storage data to ensure the app handles it gracefully (e.g., defaults to new game).",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement saveState function with JSON serialization",
            "description": "Create the saveState function to serialize the MatchState object into a JSON string and persist it using the Zepp OS settingsStorage API.",
            "dependencies": [],
            "details": "Implement the `saveState(state)` function. This function takes a `MatchState` object as input, serializes it using `JSON.stringify()`, and saves the resulting string to a specific key in the Zepp OS `settingsStorage`.",
            "status": "done",
            "testStrategy": "Test by calling the function with a valid MatchState object and verifying the data is written to storage. Ensure valid JSON stringification.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T14:42:51.978Z"
          },
          {
            "id": 2,
            "title": "Implement loadState function with error handling",
            "description": "Create the loadState function to retrieve and parse the game state, including robust error handling for missing or corrupted data.",
            "dependencies": [],
            "details": "Implement the `loadState()` function. Retrieve the raw string from `settingsStorage` using the defined key. Parse the string using `JSON.parse()` inside a try-catch block. Handle potential errors by returning `null` if data is missing or if parsing fails.",
            "status": "done",
            "testStrategy": "Test scenarios: empty storage (expect null), valid storage (expect state object), and corrupted JSON string (expect null without crashing).",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T14:42:51.982Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) Implementing the saveState function with JSON serialization, and 2) Implementing the loadState function with error handling and null checks.",
        "updatedAt": "2026-02-20T14:42:51.982Z"
      },
      {
        "id": "4",
        "title": "Padel Scoring Logic Engine",
        "description": "Develop the core state machine logic for handling points, games, sets, and tie-breaks.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "Implement the `addPoint(team)` function. Logic must handle: standard progression (0->15->30->40->Game), Deuce/Advantage rules (40-40 -> Ad -> Game or Deuce), and Game/Set increments. Implement Set logic: win at 6 games (margin of 2) or Tie-break at 6-6 (first to 7, margin of 2). Every state change must be pushed to the history stack before updating the current state to support Undo.",
        "testStrategy": "Write test cases for standard scoring, deuce scenarios (winning/losing from advantage), set wins (6-0, 6-4), and tie-break entry (6-6). Validate that the history stack grows with every point.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement standard point progression logic",
            "description": "Create the basic logic to handle point increments from 0 to 15, 30, 40, and Game for a winning team.",
            "dependencies": [],
            "details": "Define the mapping of internal point counters (0, 1, 2, 3) to display strings ('0', '15', '30', '40'). In the `addPoint(team)` function, increment the team's point counter. If the team reaches 4 points and the opponent has 3 or fewer points, award the Game.",
            "status": "done",
            "testStrategy": "Verify that calling `addPoint` updates the score from '0' to '15', '30', '40', and finally results in a Game win when the opponent is below 40.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.081Z"
          },
          {
            "id": 2,
            "title": "Implement deuce and advantage state handling",
            "description": "Develop logic to manage the 40-40 (Deuce) state and the subsequent Advantage transitions.",
            "dependencies": [
              1
            ],
            "details": "Modify `addPoint` to detect when both teams reach 3 points (40-40). If scores are equal (3-3) or higher and equal, the next point puts the scorer at 'Advantage'. If a team is at 'Advantage' and scores, they win the Game. If they lose the point, revert to 'Deuce'.",
            "status": "done",
            "testStrategy": "Test scenarios reaching 40-40, winning a point to get Advantage, and then both winning and losing the subsequent point to ensure correct Game or Deuce results.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.083Z"
          },
          {
            "id": 3,
            "title": "Implement game counting and set win conditions",
            "description": "Handle game score increments within a set and determine when a set is won based on game margins.",
            "dependencies": [
              2
            ],
            "details": "When a Game is won (from Task 1 or 2), increment the game counter for the winning team and reset points. Check set win conditions: A team wins the set if they reach 6 games and lead by at least 2 games (e.g., 6-4, 6-3, 6-0). Handle the transition to a new set or match end.",
            "status": "done",
            "testStrategy": "Test game progression to 6-0, 6-4. Verify that a score of 6-5 does not end the set. Confirm that reaching 7-5 (if allowed by logic flow) ends the set.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.085Z"
          },
          {
            "id": 4,
            "title": "Implement tie-break logic",
            "description": "Develop the specific scoring rules for a tie-break game triggered at a 6-6 game score.",
            "dependencies": [
              3
            ],
            "details": "Detect when the set score reaches 6-6. Switch to tie-break mode where points are counted as 1, 2, 3, etc., instead of 15/30/40. The first team to reach 7 points wins the tie-break and the set, provided they have a margin of at least 2 points (e.g., 7-5, 8-6). Reset points/games correctly upon completion.",
            "status": "done",
            "testStrategy": "Simulate a 6-6 set score. Verify tie-break points increment numerically. Test winning scenarios at 7-0, 7-5, and 8-6. Ensure the set concludes correctly upon winning the tie-break.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.086Z"
          },
          {
            "id": 5,
            "title": "Integrate history stack for state changes",
            "description": "Implement the mechanism to push deep copies of the state to the history stack before any score update.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "At the beginning of the `addPoint(team)` function, create a deep copy of the current match state object. Push this copy onto the `historyStack` array. This ensures that every modification to points, games, sets, or tie-break status is captured to support the Undo functionality.",
            "status": "done",
            "testStrategy": "Verify that the history stack length increases by exactly 1 for every point added. Check that popping the history restores the exact previous state without reference issues.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.087Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Standard point progression logic (0-15-30-40-Game), 2) Deuce and Advantage state handling, 3) Game counting and set win conditions, 4) Tie-break logic implementation, and 5) Integration of history stack pushing on every state change.",
        "updatedAt": "2026-02-20T15:35:54.087Z"
      },
      {
        "id": "5",
        "title": "Undo & Remove Point Logic",
        "description": "Implement the logic to reverse the last score action using the history stack.",
        "status": "done",
        "dependencies": [
          "4"
        ],
        "priority": "high",
        "details": "Implement `removePoint()` function. This function should pop the previous state from the history stack and set it as the current state. If the history is empty or score is at start (0-0, 0-0), the function should be a no-op. Ensure this effectively restores game points, set scores, and tie-break statuses.",
        "testStrategy": "Verify that pressing Undo after scoring reverts the score exactly to the previous state. Test rapid Undo presses until the score reaches 0-0 and ensure no errors occur or negative scores appear.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement removePoint() core logic in scoring engine",
            "description": "Implement the removePoint() function in the scoring engine to handle state restoration from the history stack.",
            "dependencies": [],
            "details": "Create or update utils/scoring-engine.js to include removePoint(). The function must: 1) Check if history is empty or state is initial (0-0, 0-0) -> return no-op, 2) Pop previous state from utils/history-stack.js, 3) Restore the popped state as current match state, 4) Ensure all fields (points, games, sets, tie-break status) are restored. Import historyStack and popState from utils/history-stack.js.",
            "status": "done",
            "testStrategy": "Write unit tests for single undo, multiple rapid undos, edge cases (empty history), and state integrity validation.",
            "metadata": {
              "files": [
                "utils/scoring-engine.js"
              ],
              "complexity": 2,
              "testCommand": "npm test -- scoring-engine.test.js"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:25:59.786Z"
          },
          {
            "id": 2,
            "title": "Create comprehensive unit tests for removePoint functionality",
            "description": "Write unit tests to verify the removePoint() function handles all scoring scenarios correctly.",
            "dependencies": [
              1
            ],
            "details": "Add test cases to tests/scoring-engine.test.js or create tests/remove-point.test.js. Cover: 1) Single undo after a point, 2) Multiple undos until initial state (0-0, 0-0), 3) Verify no-op when history is empty, 4) Verify no-op when already at initial state, 5) Ensure undo never produces negative scores or invalid transitions. Use createHistoryStack from utils/history-stack.js to mock history state.",
            "status": "done",
            "testStrategy": "Execute the test runner to ensure all test cases pass, including edge cases and rapid undo sequences.",
            "metadata": {
              "files": [
                "tests/scoring-engine.test.js",
                "tests/remove-point.test.js"
              ],
              "complexity": 2,
              "testCommand": "npm test"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:26:01.549Z"
          },
          {
            "id": 3,
            "title": "Integrate Undo action in app and UI layer",
            "description": "Wire up the removePoint() function to the UI layer and expose it as an action.",
            "dependencies": [
              1
            ],
            "details": "Update app.js and page/index.js. Expose a public removePoint action that calls the scoring engine function. If an Undo button exists in page/index.js UI, bind the handler to this action. Add an integration test or runtime check to verify the app's global state updates correctly after Undo is triggered, reflecting the restored state in the UI.",
            "status": "done",
            "testStrategy": "Manual test on Zepp OS simulator: click a point, then click Undo, verify UI reverts. Automated integration test to check global state restoration.",
            "metadata": {
              "files": [
                "app.js",
                "page/index.js"
              ],
              "complexity": 1,
              "testCommand": "npm run test:integration"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:26:03.053Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 1,
        "expansionPrompt": "Create a subtask to implement the removePoint function, focusing on popping from history, validation checks (empty stack), and state restoration.",
        "updatedAt": "2026-02-20T16:26:03.053Z"
      },
      {
        "id": "6",
        "title": "Home Screen UI Implementation",
        "description": "Build the Home Screen with Start and Resume functionality based on the design reference.",
        "status": "done",
        "dependencies": [
          "1",
          "3"
        ],
        "priority": "medium",
        "details": "Create `page/index` using Zepp UI components. Implement the App Title/Logo. Add 'Start New Game' and 'Resume Game' buttons. Use the `loadState` result to conditionally render the 'Resume Game' button (only if a saved game exists). Apply design tokens (colors, fonts) from the Lovable reference.",
        "testStrategy": "UI Test: Verify button placement and text match the 'Game Start' design. Functional Test: With no data, only 'Start' is shown. With data, both are shown. Clicking 'Start' clears storage and navigates. Clicking 'Resume' navigates without clearing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Home Page Structure and App Title/Logo",
            "description": "Initialize the `page/index` file and implement the static visual elements including the App Title and Logo using Zepp UI components.",
            "dependencies": [],
            "details": "Create the `page/index` file structure. Implement the App Title and Logo widgets. Apply the design tokens (colors, fonts) from the Lovable reference to ensure visual consistency with the design spec.",
            "status": "done",
            "testStrategy": "Visual inspection to ensure the App Title and Logo match the 'Game Start' design reference and the layout is correctly centered.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:49:04.579Z"
          },
          {
            "id": 2,
            "title": "Implement Start New Game Button and Logic",
            "description": "Add the 'Start New Game' button to the interface and configure the logic to clear storage and navigate to the game screen.",
            "dependencies": [
              1
            ],
            "details": "Add the 'Start New Game' button component to the layout. Implement the click event handler to clear any saved game state and navigate the user to the game page (`page/game`).",
            "status": "done",
            "testStrategy": "Functional test to verify clicking 'Start New Game' clears any existing storage and navigates correctly to the game screen.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:52:38.735Z"
          },
          {
            "id": 3,
            "title": "Implement Conditional Resume Game Button and Data Fetching",
            "description": "Integrate data fetching to check for saved games and conditionally render the 'Resume Game' button based on the result.",
            "dependencies": [
              2
            ],
            "details": "Use the `loadState` function to check for a saved game state. Conditionally render the 'Resume Game' button only if data exists. Implement the click handler to navigate using the loaded state without clearing it.",
            "status": "done",
            "testStrategy": "Functional test verifying the button only appears when saved data exists, and clicking it loads the specific state and navigates correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T17:12:16.550Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1) Creating the basic page structure and adding App Title/Logo, 2) Implementing the 'Start New Game' button and logic, and 3) Implementing the conditional 'Resume Game' button and data fetching.",
        "updatedAt": "2026-02-20T17:12:16.550Z"
      },
      {
        "id": "7",
        "title": "Game Screen Layout Construction",
        "description": "Create the layout for the Game Screen displaying scores and control buttons.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "Create `page/game`. Layout the top section for Set Scores (Games won) and the middle section for Current Game Points (0, 15, 30...). Ensure high contrast and large typography for readability. Place Team A and Team B action buttons (Add/Remove) at the bottom. Ensure layout adapts to Round vs Square screens using relative positioning or flexbox.",
        "testStrategy": "Visual inspection on Round and Square simulators to ensure elements do not overlap or get cut off. Verify text size is readable as per accessibility requirements.",
        "subtasks": [
          {
            "id": 1,
            "title": "Layout Set Score Section",
            "description": "Create the top section UI to display Set Scores (games won) for both teams.",
            "dependencies": [],
            "details": "Construct the top container in `page/game` to show Team A and Team B Set Scores. Use flexbox or relative positioning for alignment and apply high contrast colors for readability.",
            "status": "done",
            "testStrategy": "Inspect layout on simulator to ensure scores are positioned at the top and legible.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.009Z"
          },
          {
            "id": 2,
            "title": "Layout Current Game Point Section",
            "description": "Create the middle section UI displaying current game points (0, 15, 30, etc.) with large, readable typography.",
            "dependencies": [
              1
            ],
            "details": "Implement the middle container in `page/game` for Current Game Points. Define large typography styles for visibility. Ensure high contrast text is used for the point values.",
            "status": "done",
            "testStrategy": "Verify text size is sufficient for readability and contrast meets accessibility standards.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.011Z"
          },
          {
            "id": 3,
            "title": "Layout Control Buttons and Responsive Adaptation",
            "description": "Create bottom control buttons for scoring and ensure the full layout is responsive for Round and Square screens.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add Team A and Team B action buttons (Add/Remove) at the bottom of `page/game`. Apply responsive layout logic (flexbox/relative) to ensure elements fit correctly on both Round and Square screen shapes without overlap.",
            "status": "done",
            "testStrategy": "Visual inspection on Round and Square simulators. Ensure no elements are cut off and buttons are accessible.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.012Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split into: 1) Layout of the Set Score section (top), 2) Layout of the Current Game Point section (middle) with large typography, and 3) Layout of control buttons (bottom) and responsive adaptation for Round/Square screens.",
        "updatedAt": "2026-02-20T18:09:24.012Z"
      },
      {
        "id": "8",
        "title": "Game Screen Interaction & Binding",
        "description": "Connect the UI buttons to the Scoring Logic and update the view dynamically.",
        "status": "done",
        "dependencies": [
          "4",
          "5",
          "7"
        ],
        "priority": "high",
        "details": "Bind the 'Add Point' (+) and 'Remove Point' (-) buttons for both teams to the logic engine. On click: 1. Execute logic, 2. Update the UI state (re-render or update text widgets), 3. Trigger `saveState`. Ensure the UI updates within 100ms of the tap.",
        "testStrategy": "Integration test: Tap buttons and observe UI changes immediately. Verify that adding a point updates the Game Point score, and winning a game updates the Set Score. Verify persistence by closing and reopening the app.",
        "subtasks": [
          {
            "id": 1,
            "title": "Bind Game Controls to Scoring Logic",
            "description": "Attach click event listeners to the UI buttons (+/-) and invoke the scoring logic to update the game state.",
            "dependencies": [],
            "details": "Implement event handlers for Team A and Team B 'Add Point' and 'Remove Point' buttons defined in Task 7. On click, invoke the scoring engine functions (from Task 4/5) to calculate the new score. Update the specific UI widgets (Text/Score views) immediately after logic execution to reflect the new state.",
            "status": "done",
            "testStrategy": "Unit/Manual test: Click buttons and verify the displayed score changes correctly according to tennis rules. Check that removing points works correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:47:04.475Z"
          },
          {
            "id": 2,
            "title": "Implement Auto-Save and Performance Verification",
            "description": "Integrate state persistence into the click handlers and ensure UI rendering meets latency requirements.",
            "dependencies": [
              1
            ],
            "details": "Call `saveState` (from Task 3) within the button click handlers immediately after logic execution and UI update. Implement or verify logic to measure rendering latency from tap to screen update. Optimize the update loop if necessary to guarantee the UI updates within the 100ms requirement.",
            "status": "done",
            "testStrategy": "Performance test: Use console logging or profiling tools to ensure time delta between event trigger and UI paint is < 100ms. Persistence test: Close and reopen app to verify the last state is saved correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:47:05.999Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Expand into: 1) Binding Add/Remove buttons to the logic engine and triggering state updates, and 2) Implementing auto-save on state change and verifying UI update latency.",
        "updatedAt": "2026-02-20T18:47:05.999Z"
      },
      {
        "id": "9",
        "title": "Navigation & Lifecycle Handling",
        "description": "Manage navigation between screens and handle app backgrounding/foregrounding events.",
        "status": "done",
        "dependencies": [
          "6",
          "8"
        ],
        "priority": "medium",
        "details": "Implement the 'Back/Home' button logic in the Game Screen to return to the Home Screen. Add event listeners for lifecycle events (e.g., `app.on('pause')` or page hide events) to trigger `saveState` automatically, ensuring no data is lost if the user receives a call or locks the screen.",
        "testStrategy": "Navigate from Game to Home and verify save is triggered. Background the app while in a game state (simulate via tools or OS gesture) and foreground it to verify the state persists exactly as left.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Game Screen Back/Home Navigation",
            "description": "Configure the Back/Home button on the Game Screen to navigate to the Home Screen and trigger state saving.",
            "dependencies": [],
            "details": "Modify `pages/game` to handle navigation events. Implement a click handler for the Back/Home widget that first invokes `saveState()` to persist the current game score, then executes a navigation command (e.g., `router.replace` or `router.push`) to route the user back to `pages/index` (Home Screen). Ensure the transition is smooth.",
            "status": "done",
            "testStrategy": "Functional Test: Start a game session and modify the score. Tap the Back/Home button. Verify the app transitions to the Home Screen. Then, tap 'Resume Game' and verify the game state (scores) matches exactly what it was before navigation.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T21:30:27.026Z"
          },
          {
            "id": 2,
            "title": "Add Lifecycle Event Listeners for Auto-Save",
            "description": "Implement event listeners for app pause and visibility changes to automatically save the game state, preventing data loss during interruptions.",
            "dependencies": [],
            "details": "Integrate Zepp OS lifecycle event handling (e.g., `app.on('pause')` or page visibility events) within the app lifecycle or Game Screen controller. When a 'pause' or 'hide' event is detected (simulating a phone call or screen lock), automatically trigger the `saveState()` function. Ensure this happens synchronously or reliably before the app fully suspends to guarantee data integrity.",
            "status": "done",
            "testStrategy": "Lifecycle Test: Start a game and change the score. Simulate an interruption by backgrounding the app (using OS gesture or simulator tool) or triggering a 'pause' event. Foreground the app and verify the game resumes with the exact score. Verify storage to confirm data was written at the moment of pause.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T21:30:28.703Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break into: 1) Implementing navigation logic (Back/Home button) and 2) Adding lifecycle event listeners (pause/hide) for automatic state persistence.",
        "updatedAt": "2026-02-20T21:30:28.703Z"
      },
      {
        "id": "10",
        "title": "Styling Refinement, Input Debouncing & Polish",
        "description": "Apply final design styles, implement input debouncing, and optimize performance.",
        "status": "pending",
        "dependencies": [
          "9"
        ],
        "priority": "low",
        "details": "Refine the UI to strictly match the Lovable design (Game Finish, Score colors, button styles). Implement a debounce mechanism (e.g., ignore input for 300ms after a valid tap) on scoring buttons to prevent double-tap errors. Ensure touch targets are large enough (min 48px) for sports usage.",
        "testStrategy": "Perform rapid tapping tests to ensure debounce prevents double scoring. Conduct a final design audit against the provided images. Measure UI update latency to ensure <100ms compliance.",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) Applying final design styles and ensuring accessibility (touch targets), and 2) Implementing input debouncing logic to prevent double-tap errors."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-20T21:30:28.703Z",
      "taskCount": 10,
      "completedCount": 9,
      "tags": [
        "master"
      ]
    }
  }
}