{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Project Initialization & Configuration",
        "description": "Set up the Zepp OS project structure, configuration files, and base directories.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Initialize a new Zepp OS Mini Program project. Configure `app.json` with the project ID, version, and necessary permissions (e.g., storage). Set up the folder structure (pages, utils, assets). Ensure the project is configured to support both round and square screen resolutions by defining viewport settings or using responsive units (px/rpx).",
        "testStrategy": "Verify the project compiles successfully using the Zepp developer tools. Confirm that the app launches on the simulator (round and square) without crashing and displays a blank page or default index.",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Zepp OS Project and Directory Structure",
            "description": "Create the base project using the CLI and establish the folder scaffolding.",
            "dependencies": [],
            "details": "Execute the Zepp OS project initialization command to generate the boilerplate. Manually create the required directory structure including folders for 'pages', 'utils', and 'assets' to organize the codebase.",
            "status": "done",
            "testStrategy": "Verify that the project command executes without errors and all required folders exist in the file system.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.785Z"
          },
          {
            "id": 2,
            "title": "Configure Core App Metadata in app.json",
            "description": "Set the project identification and version information in the configuration file.",
            "dependencies": [
              1
            ],
            "details": "Edit the root `app.json` file to input the correct `appId`, `versionName`, `versionCode`, and `appName`. Ensure the JSON syntax is valid to prevent build errors.",
            "status": "done",
            "testStrategy": "Validate the JSON structure using a linter or the Zepp developer tools to ensure no syntax errors exist.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.791Z"
          },
          {
            "id": 3,
            "title": "Define Storage Permissions in app.json",
            "description": "Configure necessary permissions for local data access.",
            "dependencies": [
              2
            ],
            "details": "Add the appropriate permission keys to `app.json` to enable access to `storage` APIs. This is required for the subsequent implementation of local state persistence.",
            "status": "done",
            "testStrategy": "Review the configuration file to confirm permission keys are present and formatted according to Zepp OS documentation.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.794Z"
          },
          {
            "id": 4,
            "title": "Set Viewport Configuration for Round Screens",
            "description": "Configure the project settings to support circular screen resolutions.",
            "dependencies": [
              2
            ],
            "details": "Update the `app.json` or global configuration files to define the `designWidth` and viewport settings specifically tailored for round screen devices (e.g., 454px). Configure the design system to handle circular clipping zones.",
            "status": "done",
            "testStrategy": "Deploy the project to a round screen simulator and verify that the default page renders within the circular bounds without overflow.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.795Z"
          },
          {
            "id": 5,
            "title": "Set Viewport Configuration for Square Screens and Responsive Units",
            "description": "Ensure compatibility with square screens and implement responsive units.",
            "dependencies": [
              4
            ],
            "details": "Adjust configuration to support square screen resolutions. Enforce the use of responsive units (px/rpx) in the global settings or style guide to ensure layouts scale correctly across both round and square form factors.",
            "status": "done",
            "testStrategy": "Deploy to a square screen simulator. Verify elements are positioned correctly and that the layout adapts without distortion compared to the round screen view.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.797Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break this task down into subtasks covering: 1) Project creation and folder scaffolding, 2) Configuration of app.json (permissions, project ID), and 3) Viewport setup for round and square screens.",
        "updatedAt": "2026-02-20T07:17:14.797Z"
      },
      {
        "id": "2",
        "title": "Data Model & State Management Design",
        "description": "Define the data structures for the game state, scoring history, and team configurations.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Create JavaScript/TypeScript interfaces for `MatchState` including: Team A/B scores (points, games), current set status, and match status (active/finished). Implement a history stack structure to store past states for the Undo functionality (as per 'Option 2' state machine approach). Define constants for scoring sequences (0, 15, 30, 40, Ad, Game).",
        "testStrategy": "Unit tests to verify that the state object initializes correctly with zero values and that the history stack can push and pop deep copies of the state without reference errors.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interfaces for Game Entities",
            "description": "Create TypeScript interfaces for MatchState, Team configurations, and status enumerations to type-check the game data.",
            "dependencies": [],
            "details": "Define `MatchState` interface including properties for Team A/B scores (points, games), current set status, and match status (active/finished). Create supporting types for TeamScore if necessary.",
            "status": "done",
            "testStrategy": "Unit tests to verify interfaces compile correctly and accept valid data shapes for match initialization.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:11.492Z"
          },
          {
            "id": 2,
            "title": "Implement History Stack with Deep Copy Logic",
            "description": "Develop the history stack data structure required for the Undo functionality, ensuring immutability via deep copying.",
            "dependencies": [
              1
            ],
            "details": "Implement a stack class or module with `push(state)` and `pop()` methods. Integrate deep copy logic (e.g., using JSON.parse(JSON.stringify()) or a utility library) to ensure stored states are independent snapshots.",
            "status": "done",
            "testStrategy": "Unit tests to verify that pushing a state and modifying the original does not affect the stored history, and that pop correctly restores previous states.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:13.045Z"
          },
          {
            "id": 3,
            "title": "Define Scoring Constants and Enumerations",
            "description": "Establish the standard scoring sequences and domain constants used throughout the scoring logic.",
            "dependencies": [],
            "details": "Define constants for the scoring sequence (0, 15, 30, 40, Ad, Game). Create enumerations for game phases or specific states to ensure type safety in the scoring engine.",
            "status": "done",
            "testStrategy": "Validation to ensure constant values match standard Padel/Tennis scoring rules and are accessible for import by other modules.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:14.673Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1) Defining TypeScript interfaces for MatchState and related entities, 2) Implementing the history stack structure with deep copy logic, and 3) Defining scoring constants and enumerations.",
        "updatedAt": "2026-02-20T13:23:14.673Z"
      },
      {
        "id": "3",
        "title": "Local Storage & Persistence Layer",
        "description": "Implement the mechanism to save and load the game state using the device's local storage.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "Utilize Zepp OS `settingsStorage` API to persist the `MatchState` object as a JSON string. Implement `saveState(state)` and `loadState()` functions. Ensure data is serialized correctly and handle potential JSON parsing errors. The load function should return `null` if no saved game exists.",
        "testStrategy": "Manually save a state, restart the app/simulator, and verify the data is retrieved accurately. Test with invalid/corrupted storage data to ensure the app handles it gracefully (e.g., defaults to new game).",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement saveState function with JSON serialization",
            "description": "Create the saveState function to serialize the MatchState object into a JSON string and persist it using the Zepp OS settingsStorage API.",
            "dependencies": [],
            "details": "Implement the `saveState(state)` function. This function takes a `MatchState` object as input, serializes it using `JSON.stringify()`, and saves the resulting string to a specific key in the Zepp OS `settingsStorage`.",
            "status": "done",
            "testStrategy": "Test by calling the function with a valid MatchState object and verifying the data is written to storage. Ensure valid JSON stringification.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T14:42:51.978Z"
          },
          {
            "id": 2,
            "title": "Implement loadState function with error handling",
            "description": "Create the loadState function to retrieve and parse the game state, including robust error handling for missing or corrupted data.",
            "dependencies": [],
            "details": "Implement the `loadState()` function. Retrieve the raw string from `settingsStorage` using the defined key. Parse the string using `JSON.parse()` inside a try-catch block. Handle potential errors by returning `null` if data is missing or if parsing fails.",
            "status": "done",
            "testStrategy": "Test scenarios: empty storage (expect null), valid storage (expect state object), and corrupted JSON string (expect null without crashing).",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T14:42:51.982Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) Implementing the saveState function with JSON serialization, and 2) Implementing the loadState function with error handling and null checks.",
        "updatedAt": "2026-02-20T14:42:51.982Z"
      },
      {
        "id": "4",
        "title": "Padel Scoring Logic Engine",
        "description": "Develop the core state machine logic for handling points, games, sets, and tie-breaks.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "Implement the `addPoint(team)` function. Logic must handle: standard progression (0->15->30->40->Game), Deuce/Advantage rules (40-40 -> Ad -> Game or Deuce), and Game/Set increments. Implement Set logic: win at 6 games (margin of 2) or Tie-break at 6-6 (first to 7, margin of 2). Every state change must be pushed to the history stack before updating the current state to support Undo.",
        "testStrategy": "Write test cases for standard scoring, deuce scenarios (winning/losing from advantage), set wins (6-0, 6-4), and tie-break entry (6-6). Validate that the history stack grows with every point.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement standard point progression logic",
            "description": "Create the basic logic to handle point increments from 0 to 15, 30, 40, and Game for a winning team.",
            "dependencies": [],
            "details": "Define the mapping of internal point counters (0, 1, 2, 3) to display strings ('0', '15', '30', '40'). In the `addPoint(team)` function, increment the team's point counter. If the team reaches 4 points and the opponent has 3 or fewer points, award the Game.",
            "status": "done",
            "testStrategy": "Verify that calling `addPoint` updates the score from '0' to '15', '30', '40', and finally results in a Game win when the opponent is below 40.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.081Z"
          },
          {
            "id": 2,
            "title": "Implement deuce and advantage state handling",
            "description": "Develop logic to manage the 40-40 (Deuce) state and the subsequent Advantage transitions.",
            "dependencies": [
              1
            ],
            "details": "Modify `addPoint` to detect when both teams reach 3 points (40-40). If scores are equal (3-3) or higher and equal, the next point puts the scorer at 'Advantage'. If a team is at 'Advantage' and scores, they win the Game. If they lose the point, revert to 'Deuce'.",
            "status": "done",
            "testStrategy": "Test scenarios reaching 40-40, winning a point to get Advantage, and then both winning and losing the subsequent point to ensure correct Game or Deuce results.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.083Z"
          },
          {
            "id": 3,
            "title": "Implement game counting and set win conditions",
            "description": "Handle game score increments within a set and determine when a set is won based on game margins.",
            "dependencies": [
              2
            ],
            "details": "When a Game is won (from Task 1 or 2), increment the game counter for the winning team and reset points. Check set win conditions: A team wins the set if they reach 6 games and lead by at least 2 games (e.g., 6-4, 6-3, 6-0). Handle the transition to a new set or match end.",
            "status": "done",
            "testStrategy": "Test game progression to 6-0, 6-4. Verify that a score of 6-5 does not end the set. Confirm that reaching 7-5 (if allowed by logic flow) ends the set.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.085Z"
          },
          {
            "id": 4,
            "title": "Implement tie-break logic",
            "description": "Develop the specific scoring rules for a tie-break game triggered at a 6-6 game score.",
            "dependencies": [
              3
            ],
            "details": "Detect when the set score reaches 6-6. Switch to tie-break mode where points are counted as 1, 2, 3, etc., instead of 15/30/40. The first team to reach 7 points wins the tie-break and the set, provided they have a margin of at least 2 points (e.g., 7-5, 8-6). Reset points/games correctly upon completion.",
            "status": "done",
            "testStrategy": "Simulate a 6-6 set score. Verify tie-break points increment numerically. Test winning scenarios at 7-0, 7-5, and 8-6. Ensure the set concludes correctly upon winning the tie-break.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.086Z"
          },
          {
            "id": 5,
            "title": "Integrate history stack for state changes",
            "description": "Implement the mechanism to push deep copies of the state to the history stack before any score update.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "At the beginning of the `addPoint(team)` function, create a deep copy of the current match state object. Push this copy onto the `historyStack` array. This ensures that every modification to points, games, sets, or tie-break status is captured to support the Undo functionality.",
            "status": "done",
            "testStrategy": "Verify that the history stack length increases by exactly 1 for every point added. Check that popping the history restores the exact previous state without reference issues.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.087Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Standard point progression logic (0-15-30-40-Game), 2) Deuce and Advantage state handling, 3) Game counting and set win conditions, 4) Tie-break logic implementation, and 5) Integration of history stack pushing on every state change.",
        "updatedAt": "2026-02-20T15:35:54.087Z"
      },
      {
        "id": "5",
        "title": "Undo & Remove Point Logic",
        "description": "Implement the logic to reverse the last score action using the history stack.",
        "status": "done",
        "dependencies": [
          "4"
        ],
        "priority": "high",
        "details": "Implement `removePoint()` function. This function should pop the previous state from the history stack and set it as the current state. If the history is empty or score is at start (0-0, 0-0), the function should be a no-op. Ensure this effectively restores game points, set scores, and tie-break statuses.",
        "testStrategy": "Verify that pressing Undo after scoring reverts the score exactly to the previous state. Test rapid Undo presses until the score reaches 0-0 and ensure no errors occur or negative scores appear.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement removePoint() core logic in scoring engine",
            "description": "Implement the removePoint() function in the scoring engine to handle state restoration from the history stack.",
            "dependencies": [],
            "details": "Create or update utils/scoring-engine.js to include removePoint(). The function must: 1) Check if history is empty or state is initial (0-0, 0-0) -> return no-op, 2) Pop previous state from utils/history-stack.js, 3) Restore the popped state as current match state, 4) Ensure all fields (points, games, sets, tie-break status) are restored. Import historyStack and popState from utils/history-stack.js.",
            "status": "done",
            "testStrategy": "Write unit tests for single undo, multiple rapid undos, edge cases (empty history), and state integrity validation.",
            "metadata": {
              "files": [
                "utils/scoring-engine.js"
              ],
              "complexity": 2,
              "testCommand": "npm test -- scoring-engine.test.js"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:25:59.786Z"
          },
          {
            "id": 2,
            "title": "Create comprehensive unit tests for removePoint functionality",
            "description": "Write unit tests to verify the removePoint() function handles all scoring scenarios correctly.",
            "dependencies": [
              1
            ],
            "details": "Add test cases to tests/scoring-engine.test.js or create tests/remove-point.test.js. Cover: 1) Single undo after a point, 2) Multiple undos until initial state (0-0, 0-0), 3) Verify no-op when history is empty, 4) Verify no-op when already at initial state, 5) Ensure undo never produces negative scores or invalid transitions. Use createHistoryStack from utils/history-stack.js to mock history state.",
            "status": "done",
            "testStrategy": "Execute the test runner to ensure all test cases pass, including edge cases and rapid undo sequences.",
            "metadata": {
              "files": [
                "tests/scoring-engine.test.js",
                "tests/remove-point.test.js"
              ],
              "complexity": 2,
              "testCommand": "npm test"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:26:01.549Z"
          },
          {
            "id": 3,
            "title": "Integrate Undo action in app and UI layer",
            "description": "Wire up the removePoint() function to the UI layer and expose it as an action.",
            "dependencies": [
              1
            ],
            "details": "Update app.js and page/index.js. Expose a public removePoint action that calls the scoring engine function. If an Undo button exists in page/index.js UI, bind the handler to this action. Add an integration test or runtime check to verify the app's global state updates correctly after Undo is triggered, reflecting the restored state in the UI.",
            "status": "done",
            "testStrategy": "Manual test on Zepp OS simulator: click a point, then click Undo, verify UI reverts. Automated integration test to check global state restoration.",
            "metadata": {
              "files": [
                "app.js",
                "page/index.js"
              ],
              "complexity": 1,
              "testCommand": "npm run test:integration"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:26:03.053Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 1,
        "expansionPrompt": "Create a subtask to implement the removePoint function, focusing on popping from history, validation checks (empty stack), and state restoration.",
        "updatedAt": "2026-02-20T16:26:03.053Z"
      },
      {
        "id": "6",
        "title": "Home Screen UI Implementation",
        "description": "Build the Home Screen with Start and Resume functionality based on the design reference.",
        "status": "done",
        "dependencies": [
          "1",
          "3"
        ],
        "priority": "medium",
        "details": "Create `page/index` using Zepp UI components. Implement the App Title/Logo. Add 'Start New Game' and 'Resume Game' buttons. Use the `loadState` result to conditionally render the 'Resume Game' button (only if a saved game exists). Apply design tokens (colors, fonts) from the Lovable reference.",
        "testStrategy": "UI Test: Verify button placement and text match the 'Game Start' design. Functional Test: With no data, only 'Start' is shown. With data, both are shown. Clicking 'Start' clears storage and navigates. Clicking 'Resume' navigates without clearing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Home Page Structure and App Title/Logo",
            "description": "Initialize the `page/index` file and implement the static visual elements including the App Title and Logo using Zepp UI components.",
            "dependencies": [],
            "details": "Create the `page/index` file structure. Implement the App Title and Logo widgets. Apply the design tokens (colors, fonts) from the Lovable reference to ensure visual consistency with the design spec.",
            "status": "done",
            "testStrategy": "Visual inspection to ensure the App Title and Logo match the 'Game Start' design reference and the layout is correctly centered.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:49:04.579Z"
          },
          {
            "id": 2,
            "title": "Implement Start New Game Button and Logic",
            "description": "Add the 'Start New Game' button to the interface and configure the logic to clear storage and navigate to the game screen.",
            "dependencies": [
              1
            ],
            "details": "Add the 'Start New Game' button component to the layout. Implement the click event handler to clear any saved game state and navigate the user to the game page (`page/game`).",
            "status": "done",
            "testStrategy": "Functional test to verify clicking 'Start New Game' clears any existing storage and navigates correctly to the game screen.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:52:38.735Z"
          },
          {
            "id": 3,
            "title": "Implement Conditional Resume Game Button and Data Fetching",
            "description": "Integrate data fetching to check for saved games and conditionally render the 'Resume Game' button based on the result.",
            "dependencies": [
              2
            ],
            "details": "Use the `loadState` function to check for a saved game state. Conditionally render the 'Resume Game' button only if data exists. Implement the click handler to navigate using the loaded state without clearing it.",
            "status": "done",
            "testStrategy": "Functional test verifying the button only appears when saved data exists, and clicking it loads the specific state and navigates correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T17:12:16.550Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1) Creating the basic page structure and adding App Title/Logo, 2) Implementing the 'Start New Game' button and logic, and 3) Implementing the conditional 'Resume Game' button and data fetching.",
        "updatedAt": "2026-02-20T17:12:16.550Z"
      },
      {
        "id": "7",
        "title": "Game Screen Layout Construction",
        "description": "Create the layout for the Game Screen displaying scores and control buttons.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "Create `page/game`. Layout the top section for Set Scores (Games won) and the middle section for Current Game Points (0, 15, 30...). Ensure high contrast and large typography for readability. Place Team A and Team B action buttons (Add/Remove) at the bottom. Ensure layout adapts to Round vs Square screens using relative positioning or flexbox.",
        "testStrategy": "Visual inspection on Round and Square simulators to ensure elements do not overlap or get cut off. Verify text size is readable as per accessibility requirements.",
        "subtasks": [
          {
            "id": 1,
            "title": "Layout Set Score Section",
            "description": "Create the top section UI to display Set Scores (games won) for both teams.",
            "dependencies": [],
            "details": "Construct the top container in `page/game` to show Team A and Team B Set Scores. Use flexbox or relative positioning for alignment and apply high contrast colors for readability.",
            "status": "done",
            "testStrategy": "Inspect layout on simulator to ensure scores are positioned at the top and legible.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.009Z"
          },
          {
            "id": 2,
            "title": "Layout Current Game Point Section",
            "description": "Create the middle section UI displaying current game points (0, 15, 30, etc.) with large, readable typography.",
            "dependencies": [
              1
            ],
            "details": "Implement the middle container in `page/game` for Current Game Points. Define large typography styles for visibility. Ensure high contrast text is used for the point values.",
            "status": "done",
            "testStrategy": "Verify text size is sufficient for readability and contrast meets accessibility standards.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.011Z"
          },
          {
            "id": 3,
            "title": "Layout Control Buttons and Responsive Adaptation",
            "description": "Create bottom control buttons for scoring and ensure the full layout is responsive for Round and Square screens.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add Team A and Team B action buttons (Add/Remove) at the bottom of `page/game`. Apply responsive layout logic (flexbox/relative) to ensure elements fit correctly on both Round and Square screen shapes without overlap.",
            "status": "done",
            "testStrategy": "Visual inspection on Round and Square simulators. Ensure no elements are cut off and buttons are accessible.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.012Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split into: 1) Layout of the Set Score section (top), 2) Layout of the Current Game Point section (middle) with large typography, and 3) Layout of control buttons (bottom) and responsive adaptation for Round/Square screens.",
        "updatedAt": "2026-02-20T18:09:24.012Z"
      },
      {
        "id": "8",
        "title": "Game Screen Interaction & Binding",
        "description": "Connect the UI buttons to the Scoring Logic and update the view dynamically.",
        "status": "done",
        "dependencies": [
          "4",
          "5",
          "7"
        ],
        "priority": "high",
        "details": "Bind the 'Add Point' (+) and 'Remove Point' (-) buttons for both teams to the logic engine. On click: 1. Execute logic, 2. Update the UI state (re-render or update text widgets), 3. Trigger `saveState`. Ensure the UI updates within 100ms of the tap.",
        "testStrategy": "Integration test: Tap buttons and observe UI changes immediately. Verify that adding a point updates the Game Point score, and winning a game updates the Set Score. Verify persistence by closing and reopening the app.",
        "subtasks": [
          {
            "id": 1,
            "title": "Bind Game Controls to Scoring Logic",
            "description": "Attach click event listeners to the UI buttons (+/-) and invoke the scoring logic to update the game state.",
            "dependencies": [],
            "details": "Implement event handlers for Team A and Team B 'Add Point' and 'Remove Point' buttons defined in Task 7. On click, invoke the scoring engine functions (from Task 4/5) to calculate the new score. Update the specific UI widgets (Text/Score views) immediately after logic execution to reflect the new state.",
            "status": "done",
            "testStrategy": "Unit/Manual test: Click buttons and verify the displayed score changes correctly according to tennis rules. Check that removing points works correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:47:04.475Z"
          },
          {
            "id": 2,
            "title": "Implement Auto-Save and Performance Verification",
            "description": "Integrate state persistence into the click handlers and ensure UI rendering meets latency requirements.",
            "dependencies": [
              1
            ],
            "details": "Call `saveState` (from Task 3) within the button click handlers immediately after logic execution and UI update. Implement or verify logic to measure rendering latency from tap to screen update. Optimize the update loop if necessary to guarantee the UI updates within the 100ms requirement.",
            "status": "done",
            "testStrategy": "Performance test: Use console logging or profiling tools to ensure time delta between event trigger and UI paint is < 100ms. Persistence test: Close and reopen app to verify the last state is saved correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:47:05.999Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Expand into: 1) Binding Add/Remove buttons to the logic engine and triggering state updates, and 2) Implementing auto-save on state change and verifying UI update latency.",
        "updatedAt": "2026-02-20T18:47:05.999Z"
      },
      {
        "id": "9",
        "title": "Navigation & Lifecycle Handling",
        "description": "Manage navigation between screens and handle app backgrounding/foregrounding events.",
        "status": "done",
        "dependencies": [
          "6",
          "8"
        ],
        "priority": "medium",
        "details": "Implement the 'Back/Home' button logic in the Game Screen to return to the Home Screen. Add event listeners for lifecycle events (e.g., `app.on('pause')` or page hide events) to trigger `saveState` automatically, ensuring no data is lost if the user receives a call or locks the screen.",
        "testStrategy": "Navigate from Game to Home and verify save is triggered. Background the app while in a game state (simulate via tools or OS gesture) and foreground it to verify the state persists exactly as left.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Game Screen Back/Home Navigation",
            "description": "Configure the Back/Home button on the Game Screen to navigate to the Home Screen and trigger state saving.",
            "dependencies": [],
            "details": "Modify `pages/game` to handle navigation events. Implement a click handler for the Back/Home widget that first invokes `saveState()` to persist the current game score, then executes a navigation command (e.g., `router.replace` or `router.push`) to route the user back to `pages/index` (Home Screen). Ensure the transition is smooth.",
            "status": "done",
            "testStrategy": "Functional Test: Start a game session and modify the score. Tap the Back/Home button. Verify the app transitions to the Home Screen. Then, tap 'Resume Game' and verify the game state (scores) matches exactly what it was before navigation.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T21:30:27.026Z"
          },
          {
            "id": 2,
            "title": "Add Lifecycle Event Listeners for Auto-Save",
            "description": "Implement event listeners for app pause and visibility changes to automatically save the game state, preventing data loss during interruptions.",
            "dependencies": [],
            "details": "Integrate Zepp OS lifecycle event handling (e.g., `app.on('pause')` or page visibility events) within the app lifecycle or Game Screen controller. When a 'pause' or 'hide' event is detected (simulating a phone call or screen lock), automatically trigger the `saveState()` function. Ensure this happens synchronously or reliably before the app fully suspends to guarantee data integrity.",
            "status": "done",
            "testStrategy": "Lifecycle Test: Start a game and change the score. Simulate an interruption by backgrounding the app (using OS gesture or simulator tool) or triggering a 'pause' event. Foreground the app and verify the game resumes with the exact score. Verify storage to confirm data was written at the moment of pause.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T21:30:28.703Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break into: 1) Implementing navigation logic (Back/Home button) and 2) Adding lifecycle event listeners (pause/hide) for automatic state persistence.",
        "updatedAt": "2026-02-20T21:30:28.703Z"
      },
      {
        "id": "10",
        "title": "Styling Refinement, Input Debouncing & Polish",
        "description": "Apply final design styles, implement input debouncing, and optimize performance.",
        "status": "done",
        "dependencies": [
          "9"
        ],
        "priority": "low",
        "details": "Refine the UI to strictly match the Lovable design (Game Finish, Score colors, button styles). Implement a debounce mechanism (e.g., ignore input for 300ms after a valid tap) on scoring buttons to prevent double-tap errors. Ensure touch targets are large enough (min 48px) for sports usage.",
        "testStrategy": "Perform rapid tapping tests to ensure debounce prevents double scoring. Conduct a final design audit against the provided images. Measure UI update latency to ensure <100ms compliance.",
        "subtasks": [
          {
            "id": 1,
            "title": "Apply Final Design Styles and Accessibility",
            "description": "Refine the UI to strictly match the Lovable design specifications, including the Game Finish screen, score colors, and button styles. Ensure all interactive elements meet accessibility standards with a minimum touch target size of 48px suitable for sports usage.",
            "dependencies": [],
            "details": "Update styling tokens and component properties to align with the 'Game Finish' and gameplay designs. Verify contrast ratios and implement layout adjustments to guarantee touch targets are at least 48x48 pixels on all scoring and navigation controls.",
            "status": "done",
            "testStrategy": "Conduct a visual audit comparing the UI against the provided Lovable design screenshots. Measure touch targets to ensure they meet the 48px minimum requirement and verify color contrast compliance.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T07:37:53.181Z"
          },
          {
            "id": 2,
            "title": "Implement Input Debouncing Logic",
            "description": "Implement a debounce mechanism on scoring buttons to prevent double-tap errors and ensure score integrity during rapid interactions.",
            "dependencies": [],
            "details": "Modify the event handlers associated with scoring buttons (established in Task 8) to include a debounce timer. Set a 300ms window during which subsequent tap events are ignored after a valid score update to prevent accidental double scoring.",
            "status": "done",
            "testStrategy": "Perform rapid tapping tests on the scoring interface to confirm that the debounce mechanism effectively prevents multiple score increments from a single intended action. Verify UI update latency remains below 100ms.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T07:37:54.865Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) Applying final design styles and ensuring accessibility (touch targets), and 2) Implementing input debouncing logic to prevent double-tap errors.",
        "updatedAt": "2026-02-21T07:37:54.865Z"
      },
      {
        "id": "11",
        "title": "Define Match State Data Model and Storage Schema",
        "description": "Create the data structure interface for the match session that satisfies the persistence and scoring requirements defined in the PRD.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Define a TypeScript/JavaScript interface or object structure representing `MatchState`. It must include fields: `status` ('active' | 'finished'), `setsToPlay` (1|3|5), `setsNeededToWin` (1|2|3), `setsWon` ({teamA, teamB}), `currentSet` ({number, games: {teamA, teamB}}), `currentGame` ({points: {teamA, teamB}}), `setHistory` (Array of {setNumber, teamAGames, teamBGames}), and `updatedAt`. Establish a constant storage key (e.g., 'ACTIVE_MATCH_SESSION').",
        "testStrategy": "Verify that the data structure can be instantiated with all required fields and successfully serialized to JSON without data loss.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interface for MatchState",
            "description": "Create comprehensive TypeScript type definitions for the match state data structure with proper typing for all nested fields.",
            "dependencies": [],
            "details": "Define TypeScript interfaces and types: MatchState with fields status ('active'|'finished'), setsToPlay (1|3|5), setsNeededToWin (1|2|3), setsWon ({teamA, teamB}), currentSet ({number, games: {teamA, teamB}}), currentGame ({points: {teamA, teamB}}), setHistory (Array of {setNumber, teamAGames, teamBGames}), updatedAt (timestamp), and schemaVersion (number). Export all types from a central types module.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation succeeds, no type errors when creating MatchState objects, and all union types correctly restrict invalid values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:18:59.901Z"
          },
          {
            "id": 2,
            "title": "Create Default State Factory and Constants",
            "description": "Implement factory function to generate initial MatchState objects and define storage-related constants.",
            "dependencies": [
              1
            ],
            "details": "Create constant STORAGE_KEY = 'ACTIVE_MATCH_SESSION'. Implement createDefaultMatchState() factory function that returns a properly initialized MatchState object: status='active', setsToPlay=3, setsNeededToWin=2, setsWon={teamA:0, teamB:0}, currentSet={number:1, games:{teamA:0, teamB:0}}, currentGame={points:{teamA:0, teamB:0}}, setHistory=[], updatedAt=current timestamp, schemaVersion=1.",
            "status": "done",
            "testStrategy": "Test factory returns object with all required fields initialized correctly, default values match requirements, and multiple calls create independent objects (no shared references).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:01:13.890Z"
          },
          {
            "id": 3,
            "title": "Implement Serialization and Runtime Validation",
            "description": "Create functions to serialize MatchState to JSON and deserialize with runtime type validation.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement serializeMatchState(state: MatchState): string that converts state to JSON string. Implement deserializeMatchState(json: string): MatchState | null that parses JSON and validates all fields match expected types and ranges. Validation should check status values, setsToPlay in [1,3,5], setsNeededToWin in [1,2,3], numeric scores are non-negative integers. Return null if validation fails.",
            "status": "done",
            "testStrategy": "Test round-trip serialization/deserialization preserves all data. Test with malformed JSON, missing fields, invalid enum values, and negative scores to verify null returns and no crashes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:05:01.012Z"
          },
          {
            "id": 4,
            "title": "Build Storage Adapter with Abstracted API",
            "description": "Implement storage adapter with save, load, and clear functions using Zepp OS settingsStorage API.",
            "dependencies": [
              3
            ],
            "details": "Create StorageAdapter interface with save(key: string, value: string): Promise<void>, load(key: string): Promise<string | null>, clear(key: string): Promise<void>. Implement ZeppOsStorageAdapter using settingsStorage.setItem/getItem/removeItem. Create MatchStorage class that wraps the adapter with saveMatchState(state), loadMatchState(), clearMatchState() methods using STORAGE_KEY constant. Handle JSON parsing errors gracefully.",
            "status": "done",
            "testStrategy": "Test save then load retrieves identical state. Test load returns null when no data exists. Test clear removes data. Test error handling with corrupted storage data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:05.663Z"
          },
          {
            "id": 5,
            "title": "Implement Migration and Versioning Utilities",
            "description": "Create version-aware migration system to upgrade saved MatchState from older schema versions to current format.",
            "dependencies": [
              3,
              4
            ],
            "details": "Define CURRENT_SCHEMA_VERSION constant matching factory output. Create migration registry Map<number, (oldState: any) => MatchState> mapping from version to upgrade function. Implement migrateMatchState(rawData: any): MatchState that checks schemaVersion field, applies migrations sequentially from stored version to current version, or returns default state if version missing or invalid. Include migration from version 0 (no version field) to version 1.",
            "status": "done",
            "testStrategy": "Test migrating from version 0 (legacy format without version) creates valid current state. Test stored version 1 bypasses migration unchanged. Test invalid or missing version returns default state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:07.650Z"
          },
          {
            "id": 6,
            "title": "Write Unit Tests for Data Model Components",
            "description": "Create comprehensive unit tests covering instantiation, serialization, storage round-trip, and migration logic.",
            "dependencies": [
              5
            ],
            "details": "Write test suite covering: MatchState interface type checking, factory function creates valid defaults, serialization/deserialization preserves all fields including edge cases (max scores, finished status), storage adapter save/load/clear operations work correctly, migration handles legacy and current formats, and invalid data is rejected safely. Include tests for deep cloning correctness (no reference sharing in nested objects). Achieve >90% code coverage.",
            "status": "done",
            "testStrategy": "Run automated test suite. Verify all tests pass. Check code coverage report. Ensure no race conditions in async storage operations.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:09.521Z"
          },
          {
            "id": 7,
            "title": "Document Integration Notes and Task Dependencies",
            "description": "Create documentation explaining how to integrate the MatchState storage into the match lifecycle and identify dependencies.",
            "details": "Document saveMatchState() call points: after each point scored, after set completion, when match finishes, and on app pause/background. Document loadMatchState() call points: on app startup and after undo operations. Create dependency mapping: requires Task 3 (Local Storage layer) complete, provides data structure for Task 12 (Match Logic Engine). Include usage examples in JSDoc comments and a separate INTEGRATION.md file with diagrams showing state flow.",
            "status": "done",
            "testStrategy": "Review documentation for clarity and completeness. Verify dependency mappings are accurate against project task list. Peer review of integration examples.",
            "dependencies": [],
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:11.291Z"
          }
        ],
        "updatedAt": "2026-02-21T09:19:11.291Z"
      },
      {
        "id": "12",
        "title": "Implement Core Persistence Service (Save/Load)",
        "description": "Develop the utility functions to save the match state to local storage and load it back, including error handling for corrupted data.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "Implement `saveMatchState(state: MatchState)` and `loadMatchState(): MatchState | null`. Use Zepp OS `localStorage` or `settingsStorage` API to persist the JSON stringified state. `saveMatchState` should update `updatedAt` timestamp. `loadMatchState` must be wrapped in a try-catch block to handle parsing errors or missing data gracefully, returning null if data is invalid/missing (safe failure).",
        "testStrategy": "Unit test saving a state object, verifying it exists in storage. Unit test loading the object back. Test loading with corrupted JSON to ensure it returns null instead of crashing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define storage constants and initialize persistence module",
            "description": "Create the persistence service module with storage key constants and basic structure.",
            "dependencies": [],
            "details": "Create a new file for the persistence service. Define the storage key constant (e.g., 'ACTIVE_MATCH_SESSION'). Export the module structure and any necessary imports for Zepp OS storage API (localStorage or settingsStorage).",
            "status": "done",
            "testStrategy": "Verify module imports correctly and constants are exported without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:05.022Z"
          },
          {
            "id": 2,
            "title": "Implement saveMatchState function with timestamp",
            "description": "Create the saveMatchState function that updates timestamp and persists state to storage.",
            "dependencies": [
              1
            ],
            "details": "Implement saveMatchState(state: MatchState): void. Before saving, update state.updatedAt to current timestamp (Date.now()). Stringify the state using JSON.stringify(). Use Zepp OS localStorage.setItem() or settingsStorage.setItem() to persist the JSON string using the defined storage key constant.",
            "status": "done",
            "testStrategy": "Unit test saving a sample MatchState object. Verify storage contains the expected key and the stringified JSON includes the updated timestamp.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:08.348Z"
          },
          {
            "id": 3,
            "title": "Implement loadMatchState with try-catch error handling",
            "description": "Create the loadMatchState function with error handling for parsing and missing data.",
            "dependencies": [
              1
            ],
            "details": "Implement loadMatchState(): MatchState | null. Wrap the logic in try-catch block. Read from storage using localStorage.getItem() or settingsStorage.getItem(). If data is null/undefined, return null. Parse using JSON.parse(). If parsing fails (JSON error), catch the exception and return null. Return the parsed MatchState on success.",
            "status": "done",
            "testStrategy": "Unit test loading with no saved data (returns null). Test loading corrupted JSON (returns null). Test loading valid saved state (returns MatchState object).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:10.356Z"
          },
          {
            "id": 4,
            "title": "Add state validation for loaded data integrity",
            "description": "Implement validation logic to ensure loaded state has required fields and valid structure.",
            "dependencies": [
              3
            ],
            "details": "After successfully parsing JSON in loadMatchState, validate the loaded object structure. Check for required fields (e.g., status, sets, currentSet, teams). Verify data types match expected MatchState interface. If validation fails, return null to prevent app crashes from corrupted state. Optionally log validation errors for debugging.",
            "status": "done",
            "testStrategy": "Unit test loading state with missing required fields (returns null). Test loading state with invalid data types (returns null). Test loading complete valid state (returns object).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:12.222Z"
          },
          {
            "id": 5,
            "title": "Implement clearMatchState utility function",
            "description": "Create a utility to delete saved match state from storage.",
            "dependencies": [
              1
            ],
            "details": "Implement clearMatchState(): void function. Use localStorage.removeItem() or settingsStorage.setItem(key, null) to delete the saved match state. This is required for Task 19 (New Match Reset) to clear existing sessions. Export this function for use by other modules.",
            "status": "done",
            "testStrategy": "Save a match state, call clearMatchState, verify storage key is removed or null. Verify no error when clearing empty storage.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:54:12.201Z"
          },
          {
            "id": 6,
            "title": "Write comprehensive unit tests for persistence service",
            "description": "Create full test coverage for all persistence functions and edge cases.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Write unit tests covering: save functionality with timestamp verification, load with valid state, load with missing data, load with corrupted JSON, load with malformed/incomplete state, clear functionality, and sequential save-load operations. Mock the Zepp OS storage API to isolate tests. Test that updatedAt is properly updated during save.",
            "status": "done",
            "testStrategy": "Run all unit tests and ensure 100% code coverage. Verify all test cases pass including happy paths and error scenarios.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:15.911Z"
          }
        ],
        "updatedAt": "2026-02-21T09:58:15.911Z"
      },
      {
        "id": "13",
        "title": "Implement Pre-Match Setup UI and Logic",
        "description": "Create the Match Setup screen allowing users to select 1, 3, or 5 sets and initialize the match session.",
        "status": "done",
        "dependencies": [
          "11",
          "12"
        ],
        "priority": "high",
        "details": "Build the 'Match Setup' view with three buttons or a selector for sets (1, 3, 5). When a user confirms a selection: 1. Calculate `setsNeededToWin` (Math.ceil(setsToPlay / 2)), 2. Initialize a fresh `MatchState` object with scores at 0 and status 'active', 3. Call `saveMatchState`, 4. Navigate to the Game screen. Ensure this flow blocks access to the Game screen without a selection.",
        "testStrategy": "Manual QA: Verify selecting '3' sets allows entry to game. Verify default state is initialized correctly with scores at 0-0 and `setsNeededToWin` set to 2.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Match Setup UI Components",
            "description": "Build the visual interface for the match setup screen with set selection buttons",
            "dependencies": [],
            "details": "Create the Match Setup view UI with three distinct buttons/selector options for 1, 3, or 5 sets. Add a 'Start Match' confirmation button that is initially disabled. Style elements for clarity and touch interaction on Zepp OS display. Include visual feedback for selected option.",
            "status": "done",
            "testStrategy": "Visual verification of all buttons rendering correctly. Test button selection state changes. Verify touch responsiveness on each button element.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:16.182Z"
          },
          {
            "id": 2,
            "title": "Implement Match State Initialization Model",
            "description": "Create the logic to calculate setsNeededToWin and initialize MatchState object",
            "dependencies": [],
            "details": "Implement `initializeMatchState(setsToPlay: number)` function. Calculate `setsNeededToWin` using `Math.ceil(setsToPlay / 2)`. Create fresh MatchState object with: teamASets=0, teamBSets=0, currentSet={teamAGames:0, teamBGames:0, teamAPoints:0, teamBPoints:0}, setHistory=[], setsToPlay, setsNeededToWin, status='active', createdAt and updatedAt timestamps.",
            "status": "done",
            "testStrategy": "Unit test verifying MatchState initialization with 1 set (setsNeededToWin=1), 3 sets (setsNeededToWin=2), 5 sets (setsNeededToWin=3). Verify all fields are correctly initialized to zero or default values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:17.512Z"
          },
          {
            "id": 3,
            "title": "Integrate Match State Persistence",
            "description": "Connect the setup flow to save the initialized match state to storage",
            "dependencies": [
              2
            ],
            "details": "In the setup confirmation handler, call the existing `saveMatchState(state)` function (from Task 12) with the newly initialized MatchState object. Ensure this happens before navigation. Add error handling to display user feedback if save fails (e.g., toast message or inline error). Return boolean success/failure status.",
            "status": "done",
            "testStrategy": "Integration test confirming MatchState is persisted to storage after clicking Start Match button. Verify storage contains valid JSON with correct structure. Test failure scenario with mock save failure.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:18.879Z"
          },
          {
            "id": 4,
            "title": "Implement Navigation Flow to Game Screen",
            "description": "Add navigation logic to transition from Setup to Game screen after state initialization",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement `navigateToGame()` function triggered after successful state save. Use Zepp OS navigation API (e.g., `push` or `replace`) to transition to the Game screen view. Ensure Game screen loads state from storage on init. Prevent duplicate navigation calls during async operations.",
            "status": "done",
            "testStrategy": "Manual test: Complete setup flow, verify Game screen appears and displays initial 0-0 state. Test rapid button clicks to ensure no double-navigation bugs.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:20.253Z"
          },
          {
            "id": 5,
            "title": "Add Validation and Access Control",
            "description": "Implement safeguards to prevent access to Game screen without proper setup",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add validation on Setup confirmation button requiring an explicit set selection (1, 3, or 5) before enabling. Implement guard on Game screen init that checks for valid active MatchState in storage using `loadMatchState`; redirect to Setup if missing, invalid, or status is not 'active'. Block direct Game screen entry without setup completion.",
            "status": "done",
            "testStrategy": "Test attempting direct Game screen navigation without setup - should redirect to Setup. Test clicking Start Match without selection - button should remain disabled. Verify guard catches corrupted state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:21.577Z"
          },
          {
            "id": 6,
            "title": "Create Unit and Integration Tests for Setup Flow",
            "description": "Write comprehensive tests covering the complete match setup workflow",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create unit tests for `initializeMatchState` function with edge cases including invalid inputs. Create integration tests for the full flow: UI selection  state init  save  navigate. Mock storage and navigation services. Test invalid inputs, storage failures, and happy path scenarios. Ensure tests can run in CI environment.",
            "status": "done",
            "testStrategy": "Automated test suite with >80% coverage of setup flow logic. Verify all acceptance criteria: selecting '3' sets allows entry, default state initializes correctly with 0-0 scores and setsNeededToWin=2.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:22.871Z"
          }
        ],
        "updatedAt": "2026-02-21T11:36:22.871Z"
      },
      {
        "id": "14",
        "title": "Integrate Lifecycle Persistence Triggers",
        "description": "Ensure state is saved automatically on app lifecycle events (sleep, exit, background) to meet reliability requirements.",
        "status": "done",
        "dependencies": [
          "12"
        ],
        "priority": "high",
        "details": "Hook into Zepp OS lifecycle events (e.g., `page.onHide`, `app.onHide`, or specific sleep callbacks depending on API availability). In these handlers, retrieve the current runtime state and call `saveMatchState`. Additionally, ensure `saveMatchState` is called immediately after any scoring update (add/remove point).",
        "testStrategy": "Integration test: Start a match, score a few points, trigger a 'sleep' event or 'back' button press, and relaunch the app. Verify storage contains the latest score.",
        "subtasks": [
          {
            "id": 1,
            "title": "Research Zepp OS lifecycle event APIs",
            "description": "Investigate and document available lifecycle hooks in Zepp OS for handling app sleep, background, exit, and page hide events.",
            "dependencies": [],
            "details": "Review Zepp OS documentation to identify all available lifecycle callbacks including page.onHide, app.onHide, sleep callbacks, and any relevant event emitters. Test which events fire reliably in different scenarios (app backgrounding, screen lock, device sleep, back button press). Create a reference mapping of available events to their trigger conditions and reliability characteristics.",
            "status": "done",
            "testStrategy": "Create a test script that logs all lifecycle events and verify which hooks fire in simulator/emulator during various app state transitions (background, foreground, back button, screen off).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:44.791Z"
          },
          {
            "id": 2,
            "title": "Implement lifecycle event handler registration",
            "description": "Create handler functions that retrieve current runtime state and call saveMatchState when lifecycle events trigger.",
            "dependencies": [
              1
            ],
            "details": "Implement lifecycle event handler registration in the main app or game screen initialization. Create wrapper functions for each relevant lifecycle hook that retrieve the current MatchState from the state manager and pass it to saveMatchState. Ensure handlers are registered at app startup and cleaned up appropriately if needed. Handle potential errors during save operations gracefully.",
            "status": "done",
            "testStrategy": "Manually trigger lifecycle events (back button, background app) and verify through logs that saveMatchState is called with the correct state object.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:45.867Z"
          },
          {
            "id": 3,
            "title": "Integrate automatic save on scoring updates",
            "description": "Add calls to saveMatchState immediately after each scoring update operation (addPoint and removePoint).",
            "dependencies": [
              1
            ],
            "details": "Locate the addPoint and removePoint functions in the scoring logic. After each successful state mutation, call saveMatchState with the updated state. Ensure this happens synchronously before any UI updates to guarantee persistence. Verify that the save doesn't cause noticeable performance degradation in the UI. Consider batching if rapid scoring causes issues.",
            "status": "done",
            "testStrategy": "Add points multiple times rapidly and verify storage contains the correct final state after each operation. Test undo operations to ensure state persistence is maintained correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:47.307Z"
          },
          {
            "id": 4,
            "title": "Implement debounce and atomic save mechanism",
            "description": "Add debouncing logic to prevent race conditions and redundant save operations when multiple events trigger simultaneously.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement a debounced version of saveMatchState that coalesces rapid successive calls within a short window (e.g., 100-300ms). Use a flag or promise-based approach to ensure only one save operation runs at a time, preventing race conditions. The debounce should ensure the final state is saved even if multiple triggers occur in quick succession (e.g., scoring + back button pressed together). Ensure pending saves complete before app terminates.",
            "status": "done",
            "testStrategy": "Simulate rapid scoring followed immediately by a back button press. Verify only one save operation occurs and the final correct state is persisted. Test concurrent save requests to ensure no data corruption.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:48.507Z"
          },
          {
            "id": 5,
            "title": "Create integration tests for lifecycle persistence",
            "description": "Implement automated tests that simulate app lifecycle events and verify state persists correctly across app restarts.",
            "dependencies": [
              4
            ],
            "details": "Create integration test scenarios: 1) Start match, add points, trigger background/foreground cycle, verify state persists. 2) Add points, simulate sleep/power-off, relaunch, verify latest state. 3) Add points, press back, relaunch game screen, verify state restored. Mock or stub the Zepp OS lifecycle APIs if needed. Verify storage contains expected JSON structure and values. Test edge cases like empty state, zero scores, and finished matches.",
            "status": "done",
            "testStrategy": "Automated test suite covering all lifecycle scenarios with assertions on storage contents after each event. Manual testing on actual device if simulation is insufficient.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:49.732Z"
          },
          {
            "id": 6,
            "title": "Update documentation and code comments",
            "description": "Document the persistence mechanism, lifecycle handling, and debouncing approach in code comments and project documentation.",
            "dependencies": [
              5
            ],
            "details": "Add comprehensive comments to lifecycle handler registration code explaining which events are hooked and why. Document the debouncing mechanism with explanation of the race condition problem it solves. Update README or technical documentation with details on automatic state persistence behavior. Add inline comments in scoring functions noting where automatic saves occur. Document any limitations or edge cases in the persistence system.",
            "status": "done",
            "testStrategy": "Review documentation for clarity and completeness. Have another developer verify they understand the persistence mechanism from the documentation alone.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:50.831Z"
          }
        ],
        "updatedAt": "2026-02-21T13:44:50.831Z"
      },
      {
        "id": "15",
        "title": "Update Game Screen for Set Point Display",
        "description": "Modify the Game Screen UI to visualize the match-level set points (Sets Won) alongside current game scores.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "medium",
        "details": "Update the Game View UI layout to include labels or indicators for `setsWon.teamA` and `setsWon.teamB`. Bind these UI elements to the current `MatchState` data. Ensure the display updates immediately when the underlying state changes.",
        "testStrategy": "Visual QA: Verify that upon entering a game, set counters are visible and set to 0. Verify UI updates when set counts change programmatically.",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Game View layout structure",
            "description": "Examine the existing Game View layout to determine optimal placement for set point indicators without disrupting current score display.",
            "dependencies": [],
            "details": "Open the current Game View layout file. Review the existing score display sections (Game Points and Set Scores). Identify the best position for adding the Sets Won indicators, likely in the top section near team labels or alongside existing set scores. Ensure placement maintains proper spacing and doesn't cause layout overflow on round/square screens.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.319Z"
          },
          {
            "id": 2,
            "title": "Add set point UI elements to Game View",
            "description": "Create and position text labels or indicators for Team A and Team B Sets Won in the Game View layout.",
            "dependencies": [
              1
            ],
            "details": "Add two new text label widgets to the Game View UI - one for Team A sets won and one for Team B sets won. Position them based on the analysis from subtask 1. Use appropriate UI component IDs (e.g., 'teamA-sets-won', 'teamB-sets-won') for later binding. Ensure labels have placeholder text initially (e.g., '0'). Apply proper alignment relative to team labels or score displays.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.321Z"
          },
          {
            "id": 3,
            "title": "Bind setsWon properties to UI elements",
            "description": "Connect the new set point indicator labels to the MatchState setsWon.teamA and setsWon.teamB data properties.",
            "dependencies": [
              2
            ],
            "details": "In the Game View controller or binding logic, establish data bindings between the newly created UI labels and the MatchState.setsWon properties. Create reference bindings for teamA-sets-won to setsWon.teamA and teamB-sets-won to setsWon.teamB. Ensure the binding path correctly accesses the nested properties within the match state object.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.322Z"
          },
          {
            "id": 4,
            "title": "Implement reactive state update mechanism",
            "description": "Ensure the set point display updates immediately when the underlying MatchState setsWon values change.",
            "dependencies": [
              3
            ],
            "details": "Verify or implement reactive observers or state change listeners that trigger UI updates when setsWon properties are modified. Ensure the view re-renders or text content updates within 100ms of state change. If using a reactive framework (like Zepp's state management), confirm the bindings are properly reactive. If manual updates are needed, implement update functions called after state changes.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.323Z"
          },
          {
            "id": 5,
            "title": "Style set point indicators",
            "description": "Apply consistent styling to the set point labels to match the existing design system and ensure visibility.",
            "dependencies": [
              2
            ],
            "details": "Apply design tokens (colors, fonts, font sizes) to the set point indicator labels. Ensure high contrast for readability. Match the styling approach used for existing score displays. Consider adding visual hierarchy - perhaps smaller than current game points but clearly visible. Test that the styling works on both round and square screen layouts without overlapping other elements.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.324Z"
          },
          {
            "id": 6,
            "title": "Verify set point display functionality",
            "description": "Comprehensive testing of the set point display feature including initialization, updates, and visual consistency.",
            "dependencies": [
              4,
              5
            ],
            "details": "Test the complete feature: 1) Verify upon entering game, set counters are visible and correctly initialized to 0. 2) Programmatically change set counts and verify UI updates immediately. 3) Test by playing through a game and winning a set - confirm sets won increments. 4) Verify both Team A and Team B indicators update independently. 5) Check display on both round and square screen simulators for proper rendering.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.326Z"
          }
        ],
        "updatedAt": "2026-02-21T16:28:42.326Z"
      },
      {
        "id": "16",
        "title": "Implement Set Completion and Match Completion Logic",
        "description": "Develop the logic to handle set wins, update set history, reset games, and determine the match winner based on the configured format.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "Implement a function `handleGameWin(team)`. Logic: 1. Increment current set games. 2. Check Padel game win condition (e.g., >= 6 and diff >= 2). 3. If set won: Increment `setsWon` for the winner. Push final scores ({setNumber, teamAGames, teamBGames}) to `setHistory`. Reset `currentSet.games`. 4. Check match completion: If `setsWon[winner] >= setsNeededToWin`, set status to 'finished'. 5. If match finished, trigger navigation to Summary. If not, start next set.",
        "testStrategy": "Unit tests simulating game sequences to trigger set wins. Verify `setsWon` increments, `setHistory` is populated, and match status changes to 'finished' at the correct threshold.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement game score increment for winning team",
            "description": "Create function to increment the games count for the current set when a team wins a game point",
            "dependencies": [],
            "details": "Implement the first part of handleGameWin(team) that increments the current set's game count for the specified team. Update the teamAGames or teamBGames counter in the match state based on the team parameter passed to the function.",
            "status": "done",
            "testStrategy": "Unit test to verify games counter increments correctly for team A and team B independently",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:27.363Z"
          },
          {
            "id": 2,
            "title": "Implement Padel game win condition check",
            "description": "Create validation logic to determine if a set is won based on games won threshold and margin",
            "dependencies": [
              1
            ],
            "details": "Implement logic to check if the current set has been won by either team. A team wins a set if they have >= 6 games AND lead by at least 2 games (6-4, 6-0, 7-5, etc.). Return the winning team or null if no winner yet.",
            "status": "done",
            "testStrategy": "Unit tests for various score scenarios including 6-4, 7-5, 6-0 wins, and 5-5, 6-5 where no winner exists",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:30.120Z"
          },
          {
            "id": 3,
            "title": "Implement set completion and history tracking",
            "description": "Handle set win by incrementing setsWon, recording set history, and resetting current games",
            "dependencies": [
              2
            ],
            "details": "When a set is won, increment the winner's setsWon counter in match state. Push an object {setNumber, teamAGames, teamBGames} to setHistory array with current set number and final game scores. Reset currentSet.games to {teamA: 0, teamB: 0} for the next set.",
            "status": "done",
            "testStrategy": "Unit tests to verify setsWon increments correctly, setHistory is populated with proper score objects, and games reset to zero",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:32.488Z"
          },
          {
            "id": 4,
            "title": "Implement match winner determination",
            "description": "Check if match is finished by comparing setsWon to setsNeededToWin configuration",
            "dependencies": [
              3
            ],
            "details": "After a set is won, check if the winner's setsWon count meets or exceeds setsNeededToWin (e.g., 2 for best-of-3 format). If condition is met, update match status to 'finished', store the winning team identifier, and update the finishedAt timestamp.",
            "status": "done",
            "testStrategy": "Unit tests simulating 2-set win (best-of-3) and 3-set win scenarios to verify match status changes to finished at correct threshold",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:35.647Z"
          },
          {
            "id": 5,
            "title": "Implement navigation to Summary or next set",
            "description": "Trigger appropriate screen navigation based on match completion status",
            "dependencies": [
              4
            ],
            "details": "If match status is 'finished', trigger navigation to Match Summary screen (Task 18) with final state. If match continues, initialize the next set by incrementing setNumber and reset games, then ensure game screen displays updated state for new set.",
            "status": "done",
            "testStrategy": "Integration test to verify navigation to Summary after match win, and proper set initialization for continuing matches",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:38.432Z"
          }
        ],
        "updatedAt": "2026-02-21T19:22:38.432Z"
      },
      {
        "id": "17",
        "title": "Implement Home Screen Resume Logic",
        "description": "Update the Home Screen to conditionally show 'Resume Game' and handle restoring the active match state.",
        "status": "done",
        "dependencies": [
          "12"
        ],
        "priority": "high",
        "details": "On Home Screen initialization (`onShow` or `init`), call `loadMatchState`. If the result is not null AND `status === 'active'`, display the 'Resume Game' button/element. On 'Resume Game' click: 1. Load the state into the global runtime match manager. 2. Navigate to Game Screen. 3. Update UI to reflect restored state. Hide button if state is null or status is 'finished'.",
        "testStrategy": "Integration test: Create a match, exit to home. Verify 'Resume' appears. Click resume. Verify game screen opens with exact previous score. Finish a match, go home. Verify 'Resume' does not appear.",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Resume Game Button to Home Screen Layout",
            "description": "Add a new 'Resume Game' button element to the Home Screen view and configure its initial visibility state.",
            "dependencies": [],
            "details": "Create the button UI element in the Home Screen layout/template. Set its visibility to hidden/false by default. Style the button to match the existing UI theme. Position it appropriately, typically near the 'Start New Game' button for logical user flow.",
            "status": "done",
            "testStrategy": "Visual QA: Verify the Home Screen renders without the Resume Game button visible on initial load.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:08.629Z"
          },
          {
            "id": 2,
            "title": "Implement Home Screen Initialization State Check",
            "description": "Implement the logic on Home Screen initialization to check for active match state and conditionally display the Resume button.",
            "dependencies": [
              1
            ],
            "details": "In the Home Screen's onShow or init lifecycle method, call the loadMatchState() function from the persistence service (Task 12). Evaluate the returned state: if state is not null AND state.status equals 'active', set the Resume Game button visibility to true; otherwise, ensure it remains hidden. Handle null states gracefully.",
            "status": "done",
            "testStrategy": "Unit test: Mock loadMatchState to return active state - verify button shows. Mock return null or finished status - verify button stays hidden.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:10.148Z"
          },
          {
            "id": 3,
            "title": "Implement Resume Game State Loading",
            "description": "Implement the logic to load the persisted match state into the global runtime match manager when Resume Game is clicked.",
            "dependencies": [
              2
            ],
            "details": "Create a click event handler for the Resume Game button. In the handler, call loadMatchState() to retrieve the current active state. Pass this state to the global runtime match manager's initialization/load function to restore the match state in memory. Add error handling for cases where state loading fails or returns invalid data.",
            "status": "done",
            "testStrategy": "Unit test: Verify the handler calls loadMatchState and passes the result to the match manager. Test error handling when state loading fails.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:11.751Z"
          },
          {
            "id": 4,
            "title": "Implement Resume Game Navigation",
            "description": "Implement navigation from Home Screen to Game Screen after state is successfully loaded.",
            "dependencies": [
              3
            ],
            "details": "After successfully loading the state into the match manager (in the Resume click handler), trigger navigation to the Game Screen using the app's navigation router. Ensure the navigation happens only after state loading is complete and successful. Add fallback error UI if navigation or state loading fails.",
            "status": "done",
            "testStrategy": "Integration test: Click Resume button and verify the navigation router is called with Game Screen route.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:15.280Z"
          },
          {
            "id": 5,
            "title": "Implement Game Screen UI State Restoration",
            "description": "Update the Game Screen UI to reflect the restored match state when opened via Resume functionality.",
            "dependencies": [
              4
            ],
            "details": "When the Game Screen initializes, check if a match state is already loaded in the global match manager. If present, update all UI elements (team scores, current set scores, games won, serve indicators, team names, set history) to display the values from the restored state. Ensure the game appears exactly as it was when the user exited.",
            "status": "done",
            "testStrategy": "Visual QA: Create a match with specific scores, exit, resume. Verify all UI elements show exact previous state including scores, serves, and history.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:17.184Z"
          },
          {
            "id": 6,
            "title": "Testing and Documentation for Resume Logic",
            "description": "Write comprehensive tests for the resume functionality and document the implementation details.",
            "dependencies": [
              5
            ],
            "details": "Write integration tests simulating the full resume flow: create a match, exit to home, verify Resume appears, click Resume, verify Game Screen opens with correct state. Add test for finished match not showing Resume. Document the resume feature behavior, edge cases handled, and integration points in the project README or technical documentation.",
            "status": "done",
            "testStrategy": "End-to-end test: Complete full user journey from creating match, exiting, resuming, and verifying state persistence. Verify 'Resume' does not appear for finished matches.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:19.358Z"
          }
        ],
        "updatedAt": "2026-02-21T19:48:19.358Z"
      },
      {
        "id": "18",
        "title": "Implement Match Summary Screen",
        "description": "Create the Summary Screen to display the match winner, final set points, and per-set breakdown.",
        "status": "done",
        "dependencies": [
          "11",
          "16"
        ],
        "priority": "medium",
        "details": "Build the 'Match Summary' view. Display: 'Team [A/B] Wins', Final Set Score (e.g., '2-1'), and a list of sets (e.g., 'Set 1: 6-4', 'Set 2: 4-6'). Iterate through the `setHistory` array from the `MatchState` to populate the list. Add 'Home' and 'Start New Game' buttons.",
        "testStrategy": "Visual QA: Complete a 3-set match. Verify summary shows the correct winner and all 3 set scores. Verify buttons are functional.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Match Summary screen UI structure",
            "description": "Set up the basic screen layout container for the Match Summary view",
            "dependencies": [],
            "details": "Create the Match Summary screen component with Zepp OS configuration. Define the main layout structure including: header section for winner announcement, middle section for set breakdown list, and bottom section for action buttons. Configure proper screen dimensions and styling containers.",
            "status": "done",
            "testStrategy": "Verify the summary screen renders without errors when navigated to, displaying empty layout containers",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.854Z"
          },
          {
            "id": 2,
            "title": "Implement winner and final set score display",
            "description": "Add logic to determine and display the winning team and final match score",
            "dependencies": [
              1
            ],
            "details": "Extract the winning team from MatchState by comparing total sets won by Team A vs Team B. Display 'Team A Wins' or 'Team B Wins' in the header. Show the final set score (e.g., '2-1') based on the sets count from the state. Style the winner text prominently for visibility.",
            "status": "done",
            "testStrategy": "Test with both Team A and Team B winning scenarios; verify correct winner text and final score format displays accurately",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.857Z"
          },
          {
            "id": 3,
            "title": "Implement set history list rendering",
            "description": "Iterate through setHistory array and display each set's breakdown score",
            "dependencies": [
              2
            ],
            "details": "Map through the setHistory array from MatchState. For each set entry, create a list item showing 'Set N: X-Y' format where X is Team A's games and Y is Team B's games. Implement dynamic list rendering to handle variable number of sets (1-3+). Ensure proper spacing and formatting for readability.",
            "status": "done",
            "testStrategy": "Complete 2-set and 3-set matches; verify all sets display in correct order with accurate game scores (e.g., 'Set 1: 6-4', 'Set 2: 4-6', 'Set 3: 6-2')",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.858Z"
          },
          {
            "id": 4,
            "title": "Add Home and Start New Game buttons",
            "description": "Create and wire up navigation buttons at the bottom of the summary screen",
            "dependencies": [
              3
            ],
            "details": "Add two action buttons in the bottom section: 'Home' button navigates back to the Home screen using navigation API. 'Start New Game' button triggers the new match flow (integration point for Task 19). Configure proper button sizing, spacing, and touch targets for usability on the device.",
            "status": "done",
            "testStrategy": "Verify both buttons are tappable and responsive; test 'Home' navigates correctly; verify 'Start New Game' button is ready for Task 19 integration",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.860Z"
          },
          {
            "id": 5,
            "title": "Integrate summary screen into match completion flow",
            "description": "Connect Match Summary to trigger automatically when match ends and perform final testing",
            "dependencies": [
              4
            ],
            "details": "Update the scoring engine or state listener to detect when match status changes to 'finished'. Automatically navigate to Match Summary screen with the complete MatchState passed as parameter. Ensure the screen receives and displays the latest state data. Perform full end-to-end testing of the complete match-to-summary flow.",
            "status": "done",
            "testStrategy": "Visual QA: Complete a full 3-set match and verify summary shows correct winner and all 3 set scores. Test both navigation buttons. Verify edge case with 2-set finish.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.861Z"
          }
        ],
        "updatedAt": "2026-02-21T21:10:33.861Z"
      },
      {
        "id": "19",
        "title": "Implement New Match Reset and Cleanup",
        "description": "Ensure starting a new match clears the existing active session and history properly.",
        "status": "pending",
        "dependencies": [
          "12",
          "13"
        ],
        "priority": "medium",
        "details": "Implement a `startNewMatchFlow` function. This should clear the persisted `ACTIVE_MATCH_SESSION` from storage (set to null or delete key). Reset the in-memory state manager. Then navigate to the Match Setup screen (Task 13). This must be triggered from the Summary screen 'Start New Game' button and potentially the Home screen if a hard reset is needed.",
        "testStrategy": "Functional test: Finish a match. Click 'Start New Game'. Check storage to ensure old 'finished' match is cleared or overwritten. Verify setup screen appears fresh.",
        "subtasks": []
      },
      {
        "id": "20",
        "title": "Edge Case Handling and Data Validation",
        "description": "Robustness check to handle app interruptions before first point, corrupted data, and null reference safety.",
        "status": "pending",
        "dependencies": [
          "12",
          "17"
        ],
        "priority": "medium",
        "details": "Add defensive coding in `loadMatchState` and state consumers. Scenario 1: User exits immediately after setup (0 points). Ensure state saves 'active' status and loads correctly. Scenario 2: Partial data in storage. Logic must default to 'no active game' (hide resume) rather than crashing. Add checks in Game screen to ensure state exists before rendering UI.",
        "testStrategy": "QA Scenarios: 1. Setup match -> Press Back -> Open App -> Verify Resume works. 2. Manually corrupt storage file -> Open App -> Verify app loads Home safely without 'Resume'.",
        "subtasks": []
      },
      {
        "id": "21",
        "title": "Increase Add Point Button Size for Game Screen (Accessibility)",
        "description": "Refactor the Game Screen UI to ensure Add Point buttons meet the 44x44 px touch target requirement, optimizing layout for round and square Zepp OS screens without breaking existing functionality.",
        "details": "Modify the `page/game` layout to increase the dimensions of Team A and Team B Add/Remove point controls to a minimum of 44x44 px. Adjust the Points Display and Set Points display areas (referencing Task 15) to be more compact or repositioned to accommodate larger controls. Reduce non-essential UI elements (padding, chrome) if necessary to maximize space. Ensure layout logic handles dynamic sizing for Round (designWidth 454) and Square (designWidth 390) screens. Maintain event bindings established in Task 8 and ensure visual separation between interactive elements to prevent accidental adjacent taps.",
        "testStrategy": "Visual QA on Zepp OS simulator (round 454, square 390) to verify 44px minimum touch targets and adequate spacing. Conduct manual on-device rapid tap tests to verify responsiveness and prevent accidental touches. Verify accessibility standards (contrast, separation). Run regression tests for scoring flows and save/restore functionality to ensure UI changes do not break existing logic.",
        "status": "pending",
        "dependencies": [
          "7",
          "8",
          "15",
          "2",
          "4"
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-21T21:10:33.861Z",
      "taskCount": 21,
      "completedCount": 18,
      "tags": [
        "master"
      ]
    }
  },
  "qa-remediation-v1-1": {
    "tasks": [
      {
        "id": 1,
        "title": "Define Data Model and Storage Service",
        "description": "Create the persistent storage layer and data structure for the match session, ensuring compatibility with Zepp OS file system APIs.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "Implement a class or module `MatchStorage` using Zepp OS `hmFS` APIs. Define the `MatchSession` interface strictly following Section 6.1 of the PRD (status, setsToPlay, setsWon, currentSet, setHistory, etc.). Implement `saveSession(data)` that serializes the state to JSON and writes to a persistent file (e.g., `/data/match_session.json`). Implement `loadSession()` that reads, parses JSON, and returns the object. Include error handling for file corruption (return null on failure) to satisfy robustness requirements.",
        "testStrategy": "Unit tests for serialization/deserialization ensuring all fields round-trip correctly. Test corrupt data handling by writing invalid JSON to the file and verifying `loadSession` returns null without crashing.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Match Setup UI (Set Selection)",
        "description": "Create the pre-game setup screen allowing users to select the match format (1, 3, or 5 sets).",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "details": "Develop a new Zepp OS page (View) for Match Setup. Use `hmUI` widgets to create a touch-friendly interface with three distinct buttons for '1 Set', '3 Sets', and '5 Sets'. Implement event listeners for button clicks to store the selection temporarily and trigger navigation to the Game initialization logic. Ensure UI fits both round and square screen layouts.",
        "testStrategy": "Manual QA on device to verify buttons are responsive and touch targets are adequate. Verify selection is captured correctly before passing to the next logic step.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Match Initialization Logic",
        "description": "Create the logic to instantiate a fresh match session based on user setup and persist it immediately.",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "details": "Create a function `initMatch(setsToPlay)` that derives `setsNeededToWin` (e.g., 3 sets -> 2 wins). Construct the initial `MatchSession` object with `status: 'active'`, zeroed scores, and empty `setHistory`. Use `MatchStorage.saveSession` to write this initial state to storage immediately. Transition the app to the Game Screen.",
        "testStrategy": "Unit tests verifying correct `setsNeededToWin` calculation for inputs 1, 3, and 5. Verify that immediately after initialization, the storage file contains a valid 'active' session.",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Develop Scoring and Set Progression Engine",
        "description": "Implement the core game logic to handle point increments, game increments, and set transitions.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Implement functions `addPoint(team)` and `removePoint(team)`. Maintain logic for game progression (points -> games). When a team wins a game, increment `currentSet.games`. When a team wins a set (standard padel rules apply here as per assumptions), push the final score to `setHistory`, increment `setsWon` for the winning team, and reset `currentSet.games`. This task handles the in-memory state update only.",
        "testStrategy": "Unit tests simulating full sets to ensure `setHistory` is populated correctly and counters reset appropriately. Verify edge cases like deuce/advantage (existing logic) leading to game wins.",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Match Completion Logic",
        "description": "Add the logic to detect when a match has been won based on the set threshold.",
        "status": "pending",
        "dependencies": [
          4
        ],
        "priority": "high",
        "details": "In the scoring flow (Task 4), after incrementing `setsWon`, check if the value equals or exceeds `setsNeededToWin`. If so, set match `status` to 'finished'. Disable further scoring buttons/interactions on the UI. Trigger the transition to the Match Summary Screen.",
        "testStrategy": "Unit tests for all three formats (1, 3, 5 sets). Verify that reaching exactly the required number of sets ends the match, and playing extra sets (if logic were to allow it erroneously) is blocked.",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement State Restoration Service",
        "description": "Create the service responsible for loading the match state when the app starts.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "On app startup (e.g., in `init.js` or the entry point), call `MatchStorage.loadSession()`. Validate the loaded object: ensure it exists, is not null, and has valid fields (e.g., `status` is either 'active' or 'finished'). Store this state in a global singleton or state manager accessible to the UI layer. If data is invalid/corrupted, treat as no session.",
        "testStrategy": "Integration tests: Start app with a valid saved file, verify global state is populated. Start app with a corrupted file, verify app does not crash and defaults to empty state.",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Update Home Screen with Resume Game Logic",
        "description": "Modify the Home screen to conditionally display the 'Resume Game' button based on loaded state.",
        "status": "pending",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "details": "In the Home screen view logic, check the loaded global state. If `status === 'active'`, render the 'Resume Game' button using `hmUI`. If status is 'finished' or null, hide 'Resume Game'. Wire the 'Resume Game' button to navigate to the Game screen, ensuring the Game screen reads the current global state to render the exact scores and timer. Ensure 'Start New Game' is always visible.",
        "testStrategy": "Integration tests: 1. App start with active match -> Resume shows. 2. App start with finished match -> Resume hidden. 3. App start with no data -> Resume hidden.",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integrate Persistence Triggers and Lifecycle",
        "description": "Connect the storage layer to game actions and system lifecycle events to prevent data loss.",
        "status": "pending",
        "dependencies": [
          1,
          4,
          7
        ],
        "priority": "high",
        "details": "Wrap the scoring actions (Task 4) to call `MatchStorage.saveSession` immediately after every state change (point added, set won). Implement Zepp OS lifecycle listeners (e.g., `page.onHide()` or global pause event) to trigger a save when the app goes to background or the watch sleeps. Ensure writes are synchronous or handled safely to guarantee completion before sleep.",
        "testStrategy": "Lifecycle tests: Simulate pressing a point, then immediately forcing the app to background/sleep. Reopen app and verify the point is recorded. Rapidly press points and check storage integrity.",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop Match Summary Screen",
        "description": "Build the end-of-match summary screen displaying the winner and set history.",
        "status": "pending",
        "dependencies": [
          5
        ],
        "priority": "medium",
        "details": "Create a new Summary Page view. Read the `MatchSession` global state (which will have `status: 'finished'`). Display the Winner (based on `setsWon`). Display the final set score (e.g., 'Sets: 2-1'). Iterate through `setHistory` array and render a list of results (e.g., 'Set 1: 6-4'). Add 'Home' and 'Start New Game' buttons for navigation.",
        "testStrategy": "Visual QA: Complete a match and verify all sets are listed correctly and the winner is clearly identified. Verify buttons navigate to correct screens.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement New Match Reset and Cleanup",
        "description": "Ensure starting a new match clears all previous data and resets the app flow.",
        "status": "pending",
        "dependencies": [
          7,
          9
        ],
        "priority": "medium",
        "details": "Implement the logic for the 'Start New Game' buttons found on Home and Summary screens. This must call `MatchStorage.saveSession(null)` or delete the session file to clear persistence. Reset global in-memory state variables. Navigate to the Match Setup screen (Task 2) to begin the loop again. Ensure no data from the previous match affects the new one.",
        "testStrategy": "Integration test: Complete a match, view summary, click 'Start New Game', then force-close the app. Reopen and verify no 'Resume Game' option appears (confirming clean wipe).",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Increase Add Point Button Size for Game Screen (Accessibility)",
        "description": "Improve the in-game UI to make the Add Point controls significantly larger and easier to tap during play, ensuring reliable touch targets on both round and square Zepp OS screens.",
        "details": "Modify the Game Screen layout to increase the touch target size of Add Point buttons to a minimum of 44x44 px on all supported devices. This may require: 1) Reducing the points display area size or repositioning it, 2) Removing or reducing non-essential UI chrome to free up space, 3) Rearranging the button layout for optimal reachability. Ensure visual distinction between buttons with sufficient padding and spacing to prevent accidental adjacent taps. Layout must adapt dynamically for round screens (GTR-3, designWidth 454) and square screens (GTS-3, designWidth 390) while maintaining legibility. Preserve all existing scoring functionality - the add/remove point flows must continue to work and update persistent state via the existing scoring logic.",
        "testStrategy": "Visual QA on Zepp OS simulator using round (designWidth 454) and square (designWidth 390) profiles to verify touch targets meet the 44px minimum and spacing is adequate. Perform manual on-device tap tests during an active match to confirm reliable single-hand rapid taps without missed presses or accidental touches. Conduct accessibility verification: confirm button size >=44px, clear visual contrast from background, and tap areas do not overlap other interactive elements. Run regression testing with existing unit/integration tests for scoring flows. Perform manual save/restore tests to ensure persistence is unaffected by UI changes.",
        "status": "pending",
        "dependencies": [
          2,
          4,
          7
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-02-21T08:23:27.147Z",
      "updated": "2026-02-21T08:28:43.331Z",
      "description": "Tasks for qa-remediation-v1-1 context"
    }
  }
}